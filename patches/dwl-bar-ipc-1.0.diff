From 6f9ebd49fe07fe32289a4cdee18e06248e64f9f0 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Mon, 20 Feb 2023 13:36:33 -0800
Subject: [PATCH 01/11] Added IPC functionality with dwl-bar-ipc protocol.

---
 src/bar.c    |  28 ++++--
 src/bar.h    |   1 +
 src/common.h |   9 +-
 src/config.h |   5 -
 src/main.c   | 271 +++++++++++++++++++++------------------------------
 5 files changed, 137 insertions(+), 177 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 4a163e3..fe829f9 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -5,6 +5,7 @@
 #include <wayland-client-protocol.h>
 
 #include <pango-1.0/pango/pangocairo.h>
+#include <wayland-util.h>
 #include "cairo-deprecated.h"
 #include "cairo.h"
 #include "pango/pango-context.h"
@@ -77,15 +78,11 @@ struct Bar {
 };
 
 // So that the compositor can tell us when it's a good time to render again.
-const wl_callback_listener frameListener = {
-.done = frame
-};
+const wl_callback_listener frameListener = {.done = frame};
 
 // So that wlroots can tell us we need to resize.
 // We really only need to worry about this when the bar is visible (sometimes it isn't).
-const zwlr_layer_surface_v1_listener layerSurfaceListener = {
-.configure = layerSurface
-};
+const zwlr_layer_surface_v1_listener layerSurfaceListener = {.configure = layerSurface};
 
 void layerSurface(void* data, zwlr_layer_surface_v1* _, uint32_t serial, uint32_t width, uint32_t height) {
     Bar* bar = data;
@@ -183,7 +180,7 @@ void bar_component_render(Bar* bar, BarComponent* component, cairo_t* painter, u
 }
 
 void bar_tags_render(Bar* bar, cairo_t* painter, int* x) {
-    for ( int i = 0; i < LENGTH(tags); i++ ) {
+    for ( int i = 0; i < tags.size; i++ ) {
         Tag tag = bar->tags[i];
         uint tagWidth = bar_component_width(&tag.component) + bar->font.height;
 
@@ -329,12 +326,15 @@ Bar* bar_create(void) {
     pango_layout_set_text(bar->layout.layout, "[]=", -1);
     pango_layout_set_text(bar->status.layout, status, -1);
 
-    for ( int i = 0; i < LENGTH(tags); i++ ) { // Initalize the tags
+    char* str;
+    int i;
+    wl_array_for_each(str, &tags) { // Initalize the tags
         PangoLayout* layout = pango_layout_new(bar->context);
-        pango_layout_set_text(layout, tags[i], strlen(tags[i]));
+        pango_layout_set_text(layout, str, strlen(str));
         pango_layout_set_font_description(layout, bar->font.description);
         Tag tag = { 0, 0, 0, layout };
         bar->tags[i] = tag;
+        i++;
     }
 
     return bar;
@@ -366,7 +366,7 @@ void bar_destroy(Bar* bar) {
     if ( bar->title.layout )
         g_object_unref(bar->title.layout);
 
-    for ( i = 0; i < LENGTH(tags); i++) {
+    for ( i = 0; i < tags.size; i++) {
         Tag tag = bar->tags[i];
         if (tag.component.layout)
             g_object_unref(tag.component.layout);
@@ -406,7 +406,15 @@ void bar_show(Bar* bar, wl_output* output) {
     zwlr_layer_surface_v1_set_size(bar->layer_surface, 0, height);
     zwlr_layer_surface_v1_set_exclusive_zone(bar->layer_surface, height);
     wl_surface_commit(bar->surface);
+}
+
+void bar_hide(Bar* bar) {
+    if (!bar_is_visible(bar))
+        return;
 
+    zwlr_layer_surface_v1_destroy(bar->layer_surface);
+    wl_surface_destroy(bar->surface);
+    shm_destroy(bar->shm);
 }
 
 int bar_is_visible(Bar* bar) {
diff --git a/src/bar.h b/src/bar.h
index 1fbb2e0..6581aec 100644
--- a/src/bar.h
+++ b/src/bar.h
@@ -22,6 +22,7 @@ Bar* bar_create(void);
 void bar_destroy(Bar* bar);
 void bar_invalidate(Bar* bar);
 void bar_show(Bar* bar, wl_output* output);
+void bar_hide(Bar* bar);
 int bar_is_visible(Bar* bar);
 void bar_click(Bar* bar, struct Monitor* monitor, int x, int y, uint32_t button);
 void bar_set_status(Bar* bar, const char* text);
diff --git a/src/common.h b/src/common.h
index 225840c..675b62a 100644
--- a/src/common.h
+++ b/src/common.h
@@ -1,7 +1,10 @@
 #ifndef COMMON_H_
 #define COMMON_H_
+#include "dwl-bar-ipc-unstable-v1-cliet-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
 #include <sys/types.h>
 #include <stdio.h>
 #include <wayland-client-protocol.h>
@@ -37,13 +40,17 @@ typedef struct wl_array wl_array;
 typedef struct wl_cursor_theme wl_cursor_theme;
 typedef struct wl_cursor_image wl_cursor_image;
 typedef struct pollfd pollfd;
+typedef struct zdwl_output_v1 zdwl_output_v1;
+typedef struct zdwl_manager_v1 zdwl_manager_v1;
 typedef enum wl_shm_format wl_shm_format;
 
 extern wl_display* display;
 extern wl_compositor* compositor;
 extern wl_shm* shm;
 extern zwlr_layer_shell_v1* shell;
+extern zdwl_manager_v1* dwl;
 extern FILE* file;
+extern wl_array tags, layouts;
 
 struct Monitor;
 
@@ -66,8 +73,8 @@ typedef struct {
 void die(const char* fmt, ...);
 void* ecalloc(size_t amnt, size_t size);
 
+/* Logging functions */
 extern void logln(const char* str);
-
 extern void _logf(const char* fmt, ...);
 
 /*
diff --git a/src/config.h b/src/config.h
index f618aa7..dc3bfc4 100644
--- a/src/config.h
+++ b/src/config.h
@@ -31,11 +31,6 @@ static const int* schemes[3][2] = {
     [Urgent_Scheme]   = {grey1, grey3},
 };
 
-/*
- * Tags
- */
-static const char* tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
 /*
  * Buttons
  * Structure is:
diff --git a/src/main.c b/src/main.c
index 1ff83a7..77165be 100644
--- a/src/main.c
+++ b/src/main.c
@@ -25,6 +25,7 @@
 #include "common.h"
 #include "config.h"
 #include "shm.h"
+#include "dwl-bar-ipc-unstable-v1-cliet-protocol.h"
 #include "wlr-layer-shell-unstable-v1-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -34,19 +35,17 @@
  * 0 means they are the same, otherwise they are different.
  */
 #define EQUAL 0
-#define POLLFDS 4
+#define POLLFDS 3
 
-// TODO Create Github for dwl-bar then patchset for dwl-bar ipc
-//
 // TODO Get the ipc wayland protocol working.
 //      + Include a `hide` / `toggle_visibility` event so that the bar can hide itself when the user asks.
 // TODO Create dwl-ipc patchset then submit to dwl wiki.
 
 typedef struct Monitor {
-  char *xdg_name;
   uint32_t registry_name;
+  wl_output *wl_output;
 
-  wl_output *output;
+  zdwl_output_v1* dwl_output;
   Bar *bar;
   wl_list link;
 } Monitor;
@@ -56,7 +55,6 @@ typedef struct {
   Monitor* focused_monitor;
 
   int x, y;
-
   uint32_t* buttons;
   uint size;
 } Pointer;
@@ -94,9 +92,6 @@ static void setupFifo(void);
 static char* to_delimiter(char* string, ulong *start_end, char delimiter);
 static char* get_line(int fd);
 static void on_status(void);
-static void on_stdin(void);
-static void handle_stdin(char* line);
-static Monitor* monitor_from_name(char* name);
 static Monitor* monitor_from_surface(wl_surface* surface);
 static void update_monitor(Monitor* monitor);
 
@@ -107,9 +102,20 @@ static void onGlobalRemove(void *data, wl_registry *registry, uint32_t name);
 static int regHandle(void **store, HandleGlobal helper,
                      const wl_interface *interface, int version);
 
-/* xdg listener members */
+/* dwl_manager listener members */
+static void add_layout(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name);
+static void add_tag(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name);
+
+/* dwl_output listener memebers */
+static void toggle_visibility(void* data, zdwl_output_v1* zdwl_output_v1);
+static void active(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t active);
+static void set_tag(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t tag, uint32_t state, uint32_t clients, uint32_t focused);
+static void set_layout(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t layout);
+static void title(void* data, zdwl_output_v1* zdwl_output_v1, const char* title);
+static void dwl_frame(void* data, zdwl_output_v1* zdwl_output_v1);
+
+/* xdg listener member */
 static void ping(void *data, xdg_wm_base *xdg_wm_base, uint32_t serial);
-static void name(void *data, zxdg_output_v1 *output, const char *name);
 
 /* seat listener member */
 static void capabilites(void* data, wl_seat* wl_seat, uint32_t capabilities);
@@ -119,9 +125,9 @@ static void enter(void* data, wl_pointer* pointer, uint32_t serial, wl_surface*
 static void leave(void* data, wl_pointer* pointer, uint32_t serial, wl_surface* surface);
 static void motion(void* data, wl_pointer* pointer, uint32_t time, wl_fixed_t x, wl_fixed_t y);
 static void button(void* data, wl_pointer* pointer, uint32_t serial, uint32_t time, uint32_t button, uint32_t state);
-static void frame(void* data, wl_pointer* pointer);
+static void pointer_frame(void* data, wl_pointer* pointer);
 
-/* We don't do anything in these functions */
+/* Also pointer listener members, but we don't do anything in these functions */
 static void axis(void *data, struct wl_pointer *wl_pointer, uint32_t time, uint32_t axis, wl_fixed_t value) {}
 static void axis_source(void *data, struct wl_pointer *wl_pointer, uint32_t axis_source) {}
 static void axis_stop(void *data, struct wl_pointer *wl_pointer, uint32_t time, uint32_t axis) {}
@@ -133,8 +139,11 @@ wl_display *display;
 wl_compositor *compositor;
 wl_shm *shm;
 zwlr_layer_shell_v1 *shell;
-static xdg_wm_base *base;
-static zxdg_output_manager_v1 *output_manager;
+zdwl_manager_v1* dwl;
+static xdg_wm_base* base;
+
+/* dwl stuff */
+wl_array tags, layouts;
 
 /* Cursor */
 static wl_cursor_image* cursor_image;
@@ -176,17 +185,12 @@ static const struct xdg_wm_base_listener xdg_wm_base_listener = {
     .ping = ping,
 };
 
-/* So that we can get the monitor names to match with dwl monitor names. */
-static const struct zxdg_output_v1_listener xdg_output_listener = {
-    .name = name,
-};
-
 static const struct wl_pointer_listener pointer_listener = {
     .enter  = enter,
     .leave  = leave,
     .motion = motion,
     .button = button,
-    .frame  = frame,
+    .frame  = pointer_frame,
 
     .axis = axis,
     .axis_discrete = axis_discrete,
@@ -194,11 +198,73 @@ static const struct wl_pointer_listener pointer_listener = {
     .axis_stop = axis_stop,
 };
 
+static const struct zdwl_manager_v1_listener dwl_listener = {
+    .layout = add_layout,
+    .tag = add_tag,
+};
+
+static const struct zdwl_output_v1_listener dwl_ouptut_listener = {
+    .toggle_visibility = toggle_visibility,
+    .active = active,
+    .frame = dwl_frame,
+    .layout = set_layout,
+    .tag = set_tag,
+    .title = title,
+};
+
 static const struct wl_seat_listener seat_listener = {
     .capabilities = capabilites,
     .name = seat_name,
 };
 
+void add_layout(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name) {
+  void* temp = wl_array_add(&layouts, sizeof(name));
+  if (!temp)
+    return;
+
+  temp += layouts.size;
+  temp = strdup(name);
+}
+
+void add_tag(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name) {
+  void* temp = wl_array_add(&tags, sizeof(name));
+  if (!temp)
+    return;
+
+  temp += tags.size;
+  temp = strdup(name);
+}
+
+void toggle_visibility(void* data, zdwl_output_v1* zdwl_output_v1) {
+  Monitor* monitor = data;
+  bar_hide(monitor->bar);
+}
+
+void active(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t active) {
+  Monitor* monitor= data;
+  bar_set_active(monitor->bar, active);
+}
+
+void set_tag(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t tag, uint32_t state, uint32_t clients, uint32_t focused) {
+  Monitor* monitor = data;
+  bar_set_tag(monitor->bar,tag , state, clients ? 1 : 0, focused);
+}
+
+void set_layout(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t layout) {
+  Monitor* monitor = data;
+  bar_set_layout(monitor->bar, (char*)(layouts.data+layout));
+}
+
+void title(void* data, zdwl_output_v1* zdwl_output_v1, const char* title) {
+  Monitor* monitor = data;
+  bar_set_title(monitor->bar, title);
+}
+
+void dwl_frame(void* data, zdwl_output_v1* zdwl_output_v1) {
+  Monitor* monitor = data;
+  update_monitor(monitor);
+}
+
 void enter(void *data, wl_pointer *pointer, uint32_t serial,
            wl_surface *surface, wl_fixed_t x, wl_fixed_t y) {
   Seat seat = *(Seat*)data;
@@ -278,7 +344,7 @@ void button(void *data, wl_pointer *pointer, uint32_t serial, uint32_t time,
   }
 }
 
-static void frame(void* data, wl_pointer* pointer) {
+static void pointer_frame(void* data, wl_pointer* pointer) {
   Seat seat = *(Seat*)data;
   Monitor* monitor = seat.pointer->focused_monitor;
   if (!monitor) {
@@ -316,12 +382,6 @@ void capabilites(void* data, wl_seat* wl_seat, uint32_t capabilities) {
   }
 }
 
-static void name(void *data, zxdg_output_v1 *xdg_output, const char *name) {
-  Monitor *monitor = data;
-  monitor->xdg_name = strdup(name);
-  zxdg_output_v1_destroy(xdg_output);
-}
-
 void ping(void *data, struct xdg_wm_base *xdg_wm_base, uint32_t serial) {
   xdg_wm_base_pong(base, serial);
 }
@@ -343,14 +403,16 @@ void onGlobalAdd(void *_, wl_registry *registry, uint32_t name,
     return;
   if (regHandle((void **)&shm, helper, &wl_shm_interface, 1))
     return;
-  if (regHandle((void **)&output_manager, helper, &zxdg_output_manager_v1_interface, 3))
-    return;
   if (regHandle((void **)&shell, helper, &zwlr_layer_shell_v1_interface, 4))
     return;
   if (regHandle((void **)&base, helper, &xdg_wm_base_interface, 2)) {
     xdg_wm_base_add_listener(base, &xdg_wm_base_listener, NULL);
     return;
   }
+  if (regHandle((void **)&dwl, helper, &zdwl_manager_v1_interface, 1)) {
+    zdwl_manager_v1_add_listener(dwl, &dwl_listener, NULL);
+    return;
+  }
 
   {
     wl_output *output;
@@ -433,7 +495,7 @@ void globalChecks() {
   checkGlobal(shm, "wl_shm");
   checkGlobal(base, "xdg_wm_base");
   checkGlobal(shell, "wlr_layer_shell");
-  checkGlobal(output_manager, "zxdg_output_manager");
+  checkGlobal(dwl, "zdwl_manager_v1");
 
   ready = 1;
 }
@@ -442,14 +504,12 @@ void monitorSetup(uint32_t name, wl_output *output) {
   Monitor *monitor = ecalloc(1, sizeof(*monitor));
 
   monitor->bar = bar_create();
-  monitor->output = output;
+  monitor->wl_output = output;
   monitor->registry_name = name;
+  monitor->dwl_output = zdwl_manager_v1_get_output(dwl, output);
+  zdwl_output_v1_add_listener(monitor->dwl_output, &dwl_ouptut_listener, monitor);
 
   wl_list_insert(&monitors, &monitor->link);
-
-  // So we can get the monitor name.
-  zxdg_output_v1 *xdg_output = zxdg_output_manager_v1_get_xdg_output(output_manager, output);
-  zxdg_output_v1_add_listener(xdg_output, &xdg_output_listener, monitor);
 }
 
 void set_cloexec(int fd) {
@@ -512,7 +572,7 @@ void setupFifo(void) {
 
 void update_monitor(Monitor* monitor) {
   if (!bar_is_visible(monitor->bar)) {
-    bar_show(monitor->bar, monitor->output);
+    bar_show(monitor->bar, monitor->wl_output);
     return;
   }
 
@@ -520,16 +580,6 @@ void update_monitor(Monitor* monitor) {
   return;
 }
 
-Monitor* monitor_from_name(char* name) {
-  Monitor* monitor;
-  wl_list_for_each(monitor, &monitors, link) {
-    if (strcmp(name, monitor->xdg_name) == EQUAL)
-      return monitor;
-  }
-
-  return NULL;
-}
-
 Monitor* monitor_from_surface(wl_surface* surface) {
   Monitor* monitor;
   wl_list_for_each(monitor, &monitors, link) {
@@ -542,8 +592,8 @@ Monitor* monitor_from_surface(wl_surface* surface) {
 
 /*
  * Parse and extract a substring based on a delimiter
- * start_end is a pointer to a ulong that we will use to base our starting location.
- * Then fill in after as the ending point. To be used later on.
+ * start_end is a ulong that we will use to base our starting location.
+ * Then replace as the end point to be used later on.
  */
 char* to_delimiter(char* string, ulong *start_end, char delimiter) {
   char* output;
@@ -591,103 +641,6 @@ char* get_line(int fd) {
   return output;
 }
 
-void on_stdin(void) {
-  while (1) {
-    char *buffer = get_line(STDIN_FILENO);
-    if (!buffer || !strlen(buffer)) {
-      free(buffer);
-      return;
-    }
-
-    handle_stdin(buffer);
-    free(buffer);
-  }
-}
-
-void handle_stdin(char* line) {
-  char *name, *command;
-  Monitor* monitor;
-  ulong loc = 0; /* Keep track of where we are in the string `line` */
-
-  name = to_delimiter(line, &loc, ' ');
-  command = to_delimiter(line, &loc, ' ');
-  monitor = monitor_from_name(name);
-  if (!monitor)
-    return;
-  free(name);
-
-  // Hate the way these if statements look. Is being this explicit worth it?
-  if (strcmp(command, "title") == EQUAL) {
-    if (line[strlen(line)-2] == ' ') {
-      bar_set_title(monitor->bar, "");
-      goto done;
-    }
-
-    char* title = to_delimiter(line, &loc, '\n');
-    bar_set_title(monitor->bar, title);
-    free(title);
-
-  } else if (strcmp(command, "floating") == EQUAL) {
-    if (line[strlen(line)-2] == ' ') {
-      bar_set_floating(monitor->bar, 0);
-      goto done;
-    }
-
-    char* is_floating = to_delimiter(line, &loc, '\n');
-    strcmp(is_floating, "1") == EQUAL ? bar_set_floating(monitor->bar, 1) : bar_set_floating(monitor->bar, 0);
-    free(is_floating);
-
-  } else if (strcmp(command, "fullscreen") == EQUAL) {
-    /* Do nothing */
-  } else if (strcmp(command, "selmon") == EQUAL) {
-    char* selmon = to_delimiter(line, &loc, '\n');
-    strcmp(selmon, "1") == EQUAL ? bar_set_active(monitor->bar, 1) : bar_set_active(monitor->bar, 0);
-    free(selmon);
-
-  } else if (strcmp(command, "tags") == EQUAL) {
-    char *occupied_, *tags__, *clients_, *urgent_;
-    int occupied, tags_, clients, urgent, i, tag_mask;
-
-    occupied_ = to_delimiter(line, &loc, ' ');
-    tags__    = to_delimiter(line, &loc, ' ');
-    clients_  = to_delimiter(line, &loc, ' ');
-    urgent_  = to_delimiter(line,  &loc, '\n');
-
-    occupied = atoi(occupied_);
-    tags_    = atoi(tags__);
-    clients  = atoi(clients_);
-    urgent   = atoi(urgent_);
-
-    for(i = 0; i < LENGTH(tags); i++) {
-      int state = TAG_INACTIVE;
-      tag_mask = 1 << i;
-
-      if (tags_ & tag_mask)
-        state |= TAG_ACTIVE;
-      if (urgent & tag_mask)
-        state |= TAG_URGENT;
-
-      bar_set_tag(monitor->bar, i, state, occupied & tag_mask ? 1: 0, clients & tag_mask ? 1 : 0);
-    }
-
-    free(occupied_);
-    free(tags__);
-    free(clients_);
-    free(urgent_);
-
-  } else if (strcmp(command, "layout") == EQUAL) {
-    char* layout = to_delimiter(line, &loc, '\n');
-    bar_set_layout(monitor->bar, layout);
-    free(layout);
-  } else {
-    die("command unrecognized");
-  }
-
-  done:
-  free(command);
-  update_monitor(monitor);
-}
-
 void on_status(void) {
   while (1) {
     char *line = get_line(fifo_fd), *command, *status;
@@ -749,6 +702,8 @@ void setup(void) {
   wl_list_init(&seats);
   wl_list_init(&monitors);
   wl_list_init(&uninitializedOutputs);
+  wl_array_init(&tags);
+  wl_array_init(&layouts);
 
   wl_registry *registry = wl_display_get_registry(display);
   wl_registry_add_listener(registry, &registry_listener, NULL);
@@ -772,13 +727,9 @@ void setup(void) {
 
   pollfds = ecalloc(POLLFDS, sizeof(*pollfds));
 
-  pollfds[0] = (pollfd) {STDIN_FILENO, POLLIN};
-  pollfds[1] = (pollfd) {wl_display_fd, POLLIN};
-  pollfds[2] = (pollfd) {self_pipe[0], POLLIN};
-  pollfds[3] = (pollfd) {fifo_fd, POLLIN};
-
-  if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) < 0)
-    die("O_NONBLOCK");
+  pollfds[0] = (pollfd) {wl_display_fd, POLLIN};
+  pollfds[1] = (pollfd) {self_pipe[0], POLLIN};
+  pollfds[2] = (pollfd) {fifo_fd, POLLIN};
 }
 
 void run(void) {
@@ -803,8 +754,6 @@ void run(void) {
           pollfd->events = POLLIN;
           flush();
         }
-      } else if (pollfd->fd == STDIN_FILENO && (pollfd->revents & POLLIN)) {
-        on_stdin();
       } else if (pollfd->fd == fifo_fd      && (pollfd->revents & POLLIN)) {
         on_status();
       } else if (pollfd->fd == self_pipe[0] && (pollfd->revents & POLLIN)) {
@@ -823,16 +772,16 @@ void cleanup(void) {
     xdg_wm_base_destroy(base);
   if (shell)
     zwlr_layer_shell_v1_destroy(shell);
-  if (output_manager)
-    zxdg_output_manager_v1_destroy(output_manager);
-  if (fifo_path) {
-    unlink(fifo_path);
-    remove(fifo_path);
-  }
   if (file)
     fclose(file);
   if (display)
     wl_display_disconnect(display);
+  if (fifo_path) {
+    unlink(fifo_path);
+    remove(fifo_path);
+  }
+  wl_array_release(&tags);
+  wl_array_release(&layouts);
 }
 
 int main(int argc, char *argv[]) {
-- 
2.39.1


From b10653fb36933a4a83062b62eb7e668772d686fa Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 03:32:37 -0800
Subject: [PATCH 02/11] Got IPC working.

---
 .gitignore   |   1 +
 src/bar.c    | 137 ++++++++++++++++++++++++++-------------------------
 src/common.h |  15 +++---
 src/config.h |  10 ++--
 src/main.c   |  94 +++++++++++++++++++++++++++--------
 src/util.h   |  25 ----------
 6 files changed, 158 insertions(+), 124 deletions(-)
 delete mode 100644 src/util.h

diff --git a/.gitignore b/.gitignore
index 782e264..971f1a3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,3 +2,4 @@
 bar
 run
 compile_flags.txt
+log.txt
diff --git a/src/bar.c b/src/bar.c
index fe829f9..881afe8 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -20,35 +20,16 @@
 #include "wlr-layer-shell-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
-typedef struct Font Font;
-typedef struct BarComponent BarComponent;
-
-static void layerSurface(void* data, zwlr_layer_surface_v1*, uint32_t serial, uint32_t width, uint32_t height);
-static void frame(void* data, wl_callback* callback, uint32_t callback_data);
-static void bar_render(Bar* bar);
-static void bar_tags_render(Bar* bar, cairo_t* painter, int* x);
-static void bar_layout_render(Bar* bar, cairo_t* painter, int* x);
-static void bar_title_render(Bar* bar, cairo_t* painter, int* x);
-static void bar_status_render(Bar* bar, cairo_t* painter, int* x);
-static void bar_set_colorscheme(Bar* bar, const int** scheme);
-static void set_color(cairo_t* painter, const int rgba[4]);
-static void bar_color_background(Bar* bar, cairo_t* painter);
-static void bar_color_foreground(Bar* bar, cairo_t* painter);
-static Font getFont(void);
-static void bar_component_render(Bar* bar, BarComponent* component, cairo_t* painter, uint width, int* x);
-static int bar_component_width(BarComponent* component);
-static int bar_component_height(BarComponent* component);
-
-struct Font {
+typedef struct Font {
     PangoFontDescription* description;
 
     uint height; /* This is also the same as lrpad from dwm. */
-};
+} Font;
 
-struct BarComponent {
+typedef struct BarComponent {
     PangoLayout* layout;
     int x; /* Right bound of box */
-};
+} BarComponent;
 
 typedef struct {
     uint occupied;
@@ -62,7 +43,6 @@ struct Bar {
     Tag tags[9];
 
     PangoContext* context;
-    Font font;
 
     /* Colors */
     int background[4], foreground[4];
@@ -77,6 +57,25 @@ struct Bar {
     Shm* shm;
 };
 
+static void layerSurface(void* data, zwlr_layer_surface_v1*, uint32_t serial, uint32_t width, uint32_t height);
+static void frame(void* data, wl_callback* callback, uint32_t callback_data);
+static void bar_render(Bar* bar);
+static void bar_tags_render(Bar* bar, cairo_t* painter, int* x);
+static void bar_layout_render(Bar* bar, cairo_t* painter, int* x);
+static void bar_title_render(Bar* bar, cairo_t* painter, int* x);
+static void bar_status_render(Bar* bar, cairo_t* painter, int* x);
+static void bar_set_colorscheme(Bar* bar, const int** scheme);
+static void set_color(cairo_t* painter, const int rgba[4]);
+static void bar_color_background(Bar* bar, cairo_t* painter);
+static void bar_color_foreground(Bar* bar, cairo_t* painter);
+static Font getFont(void);
+static BarComponent bar_component_create(PangoContext* context, PangoFontDescription* description);
+static void bar_component_render(Bar* bar, BarComponent* component, cairo_t* painter, uint width, int* x);
+static int bar_component_width(BarComponent* component);
+static int bar_component_height(BarComponent* component);
+
+static Font bar_font = {NULL, 0};
+
 // So that the compositor can tell us when it's a good time to render again.
 const wl_callback_listener frameListener = {.done = frame};
 
@@ -135,6 +134,13 @@ Font getFont(void) {
     return in;
 }
 
+BarComponent bar_component_create(PangoContext* context, PangoFontDescription* description) {
+    PangoLayout* layout = pango_layout_new(context);
+    pango_layout_set_font_description(layout, description);
+
+    return (BarComponent){ layout, 0 };
+}
+
 int bar_component_width(BarComponent* component) {
     int w;
     pango_layout_get_size(component->layout, &w, NULL);
@@ -175,34 +181,35 @@ void bar_component_render(Bar* bar, BarComponent* component, cairo_t* painter, u
     cairo_fill(painter);
 
     bar_color_foreground(bar, painter);
-    cairo_move_to(painter, *x+(bar->font.height/2.0), 1);
+    cairo_move_to(painter, *x+(bar_font.height/2.0), 1);
     pango_cairo_show_layout(painter, component->layout);
 }
 
 void bar_tags_render(Bar* bar, cairo_t* painter, int* x) {
-    for ( int i = 0; i < tags.size; i++ ) {
-        Tag tag = bar->tags[i];
-        uint tagWidth = bar_component_width(&tag.component) + bar->font.height;
+    int i;
+    for ( i = 0; i < LENGTH(bar->tags); i++ ){
+        Tag* tag = &bar->tags[i];
+        uint tagWidth = bar_component_width(&tag->component) + bar_font.height;
 
         /* Creating the tag */
-        if (tag.state & TAG_ACTIVE) {
+        if (tag->state & TAG_ACTIVE) {
             bar_set_colorscheme(bar, schemes[Active_Scheme]);
-        } else if (tag.state & TAG_URGENT) {
+        } else if (tag->state & TAG_URGENT) {
             bar_set_colorscheme(bar, schemes[Urgent_Scheme]);
         } else {
             bar_set_colorscheme(bar, schemes[InActive_Scheme]);
         }
 
-        bar_component_render(bar, &tag.component, painter, tagWidth, x);
+        bar_component_render(bar, &tag->component, painter, tagWidth, x);
 
-        if (!tag.occupied)
+        if (!tag->occupied)
             goto done;
 
         /*  Creating the occupied tag box */
-        int boxHeight = bar->font.height / 9;
-        int boxWidth = bar->font.height / 6 + 1;
+        int boxHeight = bar_font.height / 9;
+        int boxWidth = bar_font.height / 6 + 1;
 
-        if (tag.focusedClient) {
+        if (tag->focusedClient) {
           cairo_rectangle(painter, *x + boxHeight, boxHeight, boxWidth, boxWidth);
           cairo_fill(painter);
         } else {
@@ -220,7 +227,7 @@ void bar_layout_render(Bar* bar, cairo_t* painter, int* x) {
     if (!bar)
         return;
 
-    uint layoutWidth = bar_component_width(&bar->layout) + bar->font.height;
+    uint layoutWidth = bar_component_width(&bar->layout) + bar_font.height;
 
     bar_set_colorscheme(bar, schemes[InActive_Scheme]);
     bar_component_render(bar, &bar->layout, painter, layoutWidth, x);
@@ -233,7 +240,7 @@ void bar_title_render(Bar* bar, cairo_t* painter, int* x) {
         return;
 
     // HUH For some reason ww - x - (status width) works, but ww - x - status width doesn't?
-    uint titleWidth = bar->shm->width - *x - (bar_component_width(&bar->status) + bar->font.height);
+    uint titleWidth = bar->shm->width - *x - (bar_component_width(&bar->status) + bar_font.height);
 
     bar->active ? bar_set_colorscheme(bar, schemes[Active_Scheme]) : bar_set_colorscheme(bar, schemes[InActive_Scheme]);
 
@@ -242,8 +249,8 @@ void bar_title_render(Bar* bar, cairo_t* painter, int* x) {
     if (!bar->floating)
         goto done;
 
-    int boxHeight = bar->font.height / 9;
-    int boxWidth = bar->font.height / 6 + 1;
+    int boxHeight = bar_font.height / 9;
+    int boxWidth = bar_font.height / 6 + 1;
 
     set_color(painter, grey3);
     cairo_rectangle(painter, *x + boxHeight + 0.5, boxHeight + 0.5, boxWidth, boxWidth);
@@ -258,7 +265,7 @@ void bar_status_render(Bar* bar, cairo_t* painter, int* x) {
     if (!bar)
         return;
 
-    uint statusWidth = bar_component_width(&bar->status) + bar->font.height;
+    uint statusWidth = bar_component_width(&bar->status) + bar_font.height;
 
     bar_set_colorscheme(bar, schemes[InActive_Scheme]);
     if (!bar->active && status_on_active)
@@ -268,8 +275,9 @@ void bar_status_render(Bar* bar, cairo_t* painter, int* x) {
 }
 
 void bar_render(Bar* bar) {
-    if (!bar || !bar->shm)
+    if (!bar || !bar->shm) {
         return;
+    }
 
     int x = 0; /* Keep track of the cairo cursor */
     cairo_surface_t* image = cairo_image_surface_create_for_data(shm_data(bar->shm),
@@ -304,37 +312,30 @@ Bar* bar_create(void) {
     bar->floating = 0;
 
     bar->context = pango_font_map_create_context(pango_cairo_font_map_get_default());
-    if (!bar->context)
+    if (!bar->context) {
         die("pango context");
+    }
 
-    bar->font          = getFont();
-    bar->layout.layout = pango_layout_new(bar->context);
-    bar->title.layout  = pango_layout_new(bar->context);
-    bar->status.layout = pango_layout_new(bar->context);
-
-    bar->layout.x = 0;
-    bar->title.x = 0;
-    bar->status.x = 0;
+    if (!bar_font.description)
+        bar_font = getFont();
 
-    pango_layout_set_font_description(bar->layout.layout, bar->font.description);
-    pango_layout_set_font_description(bar->title.layout, bar->font.description);
-    pango_layout_set_font_description(bar->status.layout, bar->font.description);
+    bar->layout = bar_component_create(bar->context, bar_font.description);
+    bar->title = bar_component_create(bar->context, bar_font.description);
+    bar->status = bar_component_create(bar->context, bar_font.description);
 
     char* status = ecalloc(8, sizeof(*status));
     snprintf(status, 8, "dwl %.1f", VERSION);
+    pango_layout_set_text(bar->status.layout, status, strlen(status));
 
-    pango_layout_set_text(bar->layout.layout, "[]=", -1);
-    pango_layout_set_text(bar->status.layout, status, -1);
-
-    char* str;
-    int i;
-    wl_array_for_each(str, &tags) { // Initalize the tags
+    for ( int i = 0; i < WL_ARRAY_LENGTH(&tags, char**); i++ ) { // Initalize the tags
         PangoLayout* layout = pango_layout_new(bar->context);
-        pango_layout_set_text(layout, str, strlen(str));
-        pango_layout_set_font_description(layout, bar->font.description);
+        char* name = *WL_ARRAY_AT(&tags, char**, i);
+
+        pango_layout_set_text(layout, name, strlen(name));
+        pango_layout_set_font_description(layout, bar_font.description);
+
         Tag tag = { 0, 0, 0, layout };
         bar->tags[i] = tag;
-        i++;
     }
 
     return bar;
@@ -402,7 +403,7 @@ void bar_show(Bar* bar, wl_output* output) {
     zwlr_layer_surface_v1_set_anchor(bar->layer_surface,
                                      anchor | ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT | ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);
 
-    int height = bar->font.height + 2;
+    int height = bar_font.height + 2;
     zwlr_layer_surface_v1_set_size(bar->layer_surface, 0, height);
     zwlr_layer_surface_v1_set_exclusive_zone(bar->layer_surface, height);
     wl_surface_commit(bar->surface);
@@ -426,6 +427,7 @@ int bar_is_visible(Bar* bar) {
 }
 
 void bar_set_layout(Bar *bar, const char* text) {
+    _logf("'%s' '%d'\n", text, strlen(text));
     pango_layout_set_text(bar->layout.layout, text, strlen(text));
 }
 
@@ -457,14 +459,15 @@ wl_surface* bar_get_surface(Bar *bar) {
 }
 
 void bar_click(Bar* bar, struct Monitor* monitor, int x, int y, uint32_t button) {
-    Arg* arg = NULL;
+    Arg *argp = NULL, arg;
     Clicked location = Click_None;
 
     if (x < bar->tags[LENGTH(bar->tags)-1].component.x) {
         location = Click_Tag;
         for (int i = 0; i < LENGTH(bar->tags); i++) {
             if (x < bar->tags[i].component.x) {
-                arg->ui = 1<<i;
+                arg.ui = 1<<i;
+                argp = &arg;
                 break;
             }
         }
@@ -481,7 +484,9 @@ void bar_click(Bar* bar, struct Monitor* monitor, int x, int y, uint32_t button)
 
     for (int i = 0; i < LENGTH(buttons); i++) {
         if (buttons[i].location == location && buttons[i].button == button) {
-            buttons[i].func(monitor, arg ? arg : &buttons[i].arg);
+            logln("found button");
+            buttons[i].func(monitor, argp ? argp : &buttons[i].arg);
+            logln("after button function");
             return;
         }
     }
diff --git a/src/common.h b/src/common.h
index 675b62a..f42eee2 100644
--- a/src/common.h
+++ b/src/common.h
@@ -11,8 +11,10 @@
 #include <linux/input-event-codes.h>
 #include <wayland-cursor.h>
 
-#define LENGTH(X) (sizeof X / sizeof X[0] )
 #define VERSION 1.0
+#define LENGTH(X) (sizeof X / sizeof X[0] )
+#define WL_ARRAY_LENGTH(array, type) ((array)->size/sizeof(type))
+#define WL_ARRAY_AT(array, type, index) ((type)((array)->data)+index)
 
 // Commonly used typedefs which makes using these structs easier.
 typedef struct wl_registry wl_registry;
@@ -48,7 +50,6 @@ extern wl_display* display;
 extern wl_compositor* compositor;
 extern wl_shm* shm;
 extern zwlr_layer_shell_v1* shell;
-extern zdwl_manager_v1* dwl;
 extern FILE* file;
 extern wl_array tags, layouts;
 
@@ -81,10 +82,10 @@ extern void _logf(const char* fmt, ...);
  * User function definitions.
  * Usually used for when clicking buttons with a pointer.
  */
-void spawn(struct Monitor* monitor, const Arg* arg);
-void layout(struct Monitor* monitor, const Arg* arg);
-void view(struct Monitor* monitor, const Arg* arg);
-void toggle_view(struct Monitor* monitor, const Arg* arg);
-void tag(struct Monitor* monitor, const Arg* arg);
+extern void spawn(struct Monitor* monitor, const Arg* arg);
+extern void layout(struct Monitor* monitor, const Arg* arg);
+extern void view(struct Monitor* monitor, const Arg* arg);
+extern void toggle_view(struct Monitor* monitor, const Arg* arg);
+extern void tag(struct Monitor* monitor, const Arg* arg);
 
 #endif // COMMON_H_
diff --git a/src/config.h b/src/config.h
index dc3bfc4..0e6112d 100644
--- a/src/config.h
+++ b/src/config.h
@@ -37,11 +37,11 @@ static const int* schemes[3][2] = {
  * { click location, button clicked (linux event codes), function to run, other argument input (usage varies) }
  */
 static const Button buttons[] = {
-//{ Click_Tag,    BTN_LEFT,   view,         {0}},
-//{ Click_Tag,    BTN_MIDDLE, tag,          {0}},
-//{ Click_Tag,    BTN_RIGHT,  toggle_view,  {0}},
-//{ Click_Layout, BTN_LEFT,   layout,       {.ui = 0}},
-//{ Click_Layout, BTN_RIGHT,  layout,       {.ui = 1}},
+{ Click_Tag,    BTN_LEFT,   view,         {0}},
+{ Click_Tag,    BTN_MIDDLE, tag,          {0}},
+{ Click_Tag,    BTN_RIGHT,  toggle_view,  {0}},
+{ Click_Layout, BTN_LEFT,   layout,       {.ui = 0}},
+{ Click_Layout, BTN_RIGHT,  layout,       {.ui = 1}},
 { Click_Status, BTN_MIDDLE, spawn,        {.v = terminal } },
 };
 
diff --git a/src/main.c b/src/main.c
index 77165be..17b9354 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,4 +1,5 @@
 #include <asm-generic/errno-base.h>
+#include <math.h>
 #include <stdarg.h>
 #include <stddef.h>
 #include <wayland-client-core.h>
@@ -45,6 +46,10 @@ typedef struct Monitor {
   uint32_t registry_name;
   wl_output *wl_output;
 
+  uint layout;
+  uint tags;
+  uint visibilty;
+
   zdwl_output_v1* dwl_output;
   Bar *bar;
   wl_list link;
@@ -139,7 +144,7 @@ wl_display *display;
 wl_compositor *compositor;
 wl_shm *shm;
 zwlr_layer_shell_v1 *shell;
-zdwl_manager_v1* dwl;
+static zdwl_manager_v1* dwl;
 static xdg_wm_base* base;
 
 /* dwl stuff */
@@ -218,41 +223,45 @@ static const struct wl_seat_listener seat_listener = {
 };
 
 void add_layout(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name) {
-  void* temp = wl_array_add(&layouts, sizeof(name));
+  void* temp = wl_array_add(&layouts, sizeof(char**));
   if (!temp)
     return;
 
-  temp += layouts.size;
-  temp = strdup(name);
+  char* dup = strdup(name);
+
+  memcpy(temp, &dup, sizeof(char**));
 }
 
 void add_tag(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name) {
-  void* temp = wl_array_add(&tags, sizeof(name));
+  void* temp = wl_array_add(&tags, sizeof(char**));
   if (!temp)
     return;
 
-  temp += tags.size;
-  temp = strdup(name);
+  char* dup = strdup(name); /* Gain ownership of name */
+
+  memcpy(temp, &dup, sizeof(char**)); /* Copy a pointer of it into the array */;
 }
 
 void toggle_visibility(void* data, zdwl_output_v1* zdwl_output_v1) {
   Monitor* monitor = data;
+  monitor->visibilty = ~monitor->visibilty;
   bar_hide(monitor->bar);
 }
 
 void active(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t active) {
-  Monitor* monitor= data;
+  Monitor* monitor = data;
   bar_set_active(monitor->bar, active);
 }
 
 void set_tag(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t tag, uint32_t state, uint32_t clients, uint32_t focused) {
   Monitor* monitor = data;
-  bar_set_tag(monitor->bar,tag , state, clients ? 1 : 0, focused);
+  bar_set_tag(monitor->bar, tag, state, clients ? 1 : 0, focused);
+  monitor->tags = (state & ZDWL_OUTPUT_V1_TAG_STATE_ACTIVE) ? monitor->tags | (1 << tag) : monitor->tags & ~(1 << tag);
 }
 
 void set_layout(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t layout) {
   Monitor* monitor = data;
-  bar_set_layout(monitor->bar, (char*)(layouts.data+layout));
+  bar_set_layout(monitor->bar, *WL_ARRAY_AT(&layouts, char**, layout));
 }
 
 void title(void* data, zdwl_output_v1* zdwl_output_v1, const char* title) {
@@ -296,17 +305,17 @@ void motion(void* data, wl_pointer* pointer, uint32_t time, wl_fixed_t x, wl_fix
 void button(void *data, wl_pointer *pointer, uint32_t serial, uint32_t time,
             uint32_t button, uint32_t state) {
   Seat seat = *(Seat*)data;
+  uint32_t* new_buttons = NULL;
   int i, prev = -1; /* The index of this button */
 
   for (i = 0; i < seat.pointer->size; i++) {
-    _logf("'%d' ", seat.pointer->buttons[i]);
     if (seat.pointer->buttons[i] == button)
       prev = i;
   }
 
   /* If this button was newly pressed. */
   if (state == WL_POINTER_BUTTON_STATE_PRESSED && prev == -1) {
-    uint32_t* new_buttons = ecalloc(seat.pointer->size+1, sizeof(uint32_t));
+    new_buttons = ecalloc(seat.pointer->size+1, sizeof(uint32_t));
     for (i = 0; i < seat.pointer->size+1; i++) {
       if (i == seat.pointer->size) {
         new_buttons[i] = button;
@@ -316,15 +325,12 @@ void button(void *data, wl_pointer *pointer, uint32_t serial, uint32_t time,
       new_buttons[i] = seat.pointer->buttons[i];
     }
 
-    free(seat.pointer->buttons);
-    seat.pointer->buttons = new_buttons;
     seat.pointer->size++;
-    return;
   }
 
   /* If this button was released and we have it. */
   if(state == WL_KEYBOARD_KEY_STATE_RELEASED && prev != -1) {
-    uint32_t* new_buttons = ecalloc(seat.pointer->size-1, sizeof(uint32_t));
+    new_buttons = ecalloc(seat.pointer->size-1, sizeof(uint32_t));
     for (i = 0; i < seat.pointer->size; i++) {
       if (i == prev)
         continue;
@@ -336,12 +342,12 @@ void button(void *data, wl_pointer *pointer, uint32_t serial, uint32_t time,
         new_buttons[i-1] = seat.pointer->buttons[i];
     }
 
-    free(seat.pointer->buttons);
-    seat.pointer->buttons = new_buttons;
     seat.pointer->size--;
-
-    return;
   }
+
+  free(seat.pointer->buttons);
+  seat.pointer->buttons = new_buttons;
+  return;
 }
 
 static void pointer_frame(void* data, wl_pointer* pointer) {
@@ -478,6 +484,34 @@ void spawn(Monitor* monitor, const Arg *arg) {
   exit(1);
 }
 
+void layout(Monitor* monitor, const Arg* arg) {
+  if (!arg->ui && monitor->layout > 0) {
+    logln("decrement");
+    monitor->layout--;
+  } else if (arg->ui && monitor->layout < WL_ARRAY_LENGTH(&layouts, char**)) {
+    logln("increment");
+    monitor->layout++;
+  } else {
+    return;
+  }
+
+  zdwl_output_v1_set_layout(monitor->dwl_output, monitor->layout);
+  logln("layout");
+}
+
+void view(struct Monitor* monitor, const Arg* arg) {
+  zdwl_output_v1_set_tags(monitor->dwl_output, arg->ui, 1);
+  logln("viewed");
+}
+
+void toggle_view(struct Monitor* monitor, const Arg* arg) {
+  zdwl_output_v1_set_tags(monitor->dwl_output, monitor->tags ^ arg->ui, 0);
+}
+
+void tag(struct Monitor* monitor, const Arg* arg) {
+  zdwl_output_v1_set_client_tags(monitor->dwl_output, 0, arg->ui);
+}
+
 void checkGlobal(void *global, const char *name) {
   if (global)
     return;
@@ -506,6 +540,8 @@ void monitorSetup(uint32_t name, wl_output *output) {
   monitor->bar = bar_create();
   monitor->wl_output = output;
   monitor->registry_name = name;
+  monitor->layout = 0;
+  monitor->visibilty = 1;
   monitor->dwl_output = zdwl_manager_v1_get_output(dwl, output);
   zdwl_output_v1_add_listener(monitor->dwl_output, &dwl_ouptut_listener, monitor);
 
@@ -571,6 +607,10 @@ void setupFifo(void) {
 }
 
 void update_monitor(Monitor* monitor) {
+  if (!monitor->visibilty) {
+    return;
+  }
+
   if (!bar_is_visible(monitor->bar)) {
     bar_show(monitor->bar, monitor->wl_output);
     return;
@@ -730,6 +770,9 @@ void setup(void) {
   pollfds[0] = (pollfd) {wl_display_fd, POLLIN};
   pollfds[1] = (pollfd) {self_pipe[0], POLLIN};
   pollfds[2] = (pollfd) {fifo_fd, POLLIN};
+
+  if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) < 0)
+    die("O_NONBLOCK");
 }
 
 void run(void) {
@@ -747,8 +790,9 @@ void run(void) {
         die("POLLNVAL");
 
       if (pollfd->fd == wl_display_fd) {
-        if ((pollfd->revents & POLLIN) && (wl_display_dispatch(display) < 0))
+        if ((pollfd->revents & POLLIN) && (wl_display_dispatch(display) < 0)) {
           die("wl_display_dispatch");
+        }
 
         if (pollfd->revents & POLLOUT) {
           pollfd->events = POLLIN;
@@ -780,7 +824,15 @@ void cleanup(void) {
     unlink(fifo_path);
     remove(fifo_path);
   }
+  char** ptr;
+  wl_array_for_each(ptr, &tags) {
+    free(*ptr);
+  }
   wl_array_release(&tags);
+  ptr = NULL;
+  wl_array_for_each(ptr, &tags) {
+    free(*ptr);
+  }
   wl_array_release(&layouts);
 }
 
diff --git a/src/util.h b/src/util.h
deleted file mode 100644
index 8e61726..0000000
--- a/src/util.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef UTIL_H_
-#define UTIL_H_
-#include <sys/types.h>
-#include <stddef.h>
-
-typedef struct {
-    void* ptr;
-    uint size;
-} Stack;
-
-#define stack_for_each(pos, stack) \
-    for (pos = (stack)->data); \
-    (const char*) pos < ((const char*) (stack)->data + (stack)->size); \
-    (pos)++)
-
-
-inline void stack_init(Stack* stack) {
-    stack->ptr = NULL;
-    stack->size = 0;
-}
-
-void* stack_end(Stack* stack);
-void* stack_push(Stack* stack);
-
-#endif // UTIL_H_
-- 
2.39.1


From 69e0b606b80b1df64ca8999bf4d7a77319002380 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 14:46:12 -0800
Subject: [PATCH 03/11] Small things.

---
 src/bar.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 881afe8..257ab91 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -186,8 +186,7 @@ void bar_component_render(Bar* bar, BarComponent* component, cairo_t* painter, u
 }
 
 void bar_tags_render(Bar* bar, cairo_t* painter, int* x) {
-    int i;
-    for ( i = 0; i < LENGTH(bar->tags); i++ ){
+    for ( int i = 0; i < LENGTH(bar->tags); i++ ){
         Tag* tag = &bar->tags[i];
         uint tagWidth = bar_component_width(&tag->component) + bar_font.height;
 
@@ -320,9 +319,10 @@ Bar* bar_create(void) {
         bar_font = getFont();
 
     bar->layout = bar_component_create(bar->context, bar_font.description);
-    bar->title = bar_component_create(bar->context, bar_font.description);
+    bar->title  = bar_component_create(bar->context, bar_font.description);
     bar->status = bar_component_create(bar->context, bar_font.description);
 
+    /* Default status */
     char* status = ecalloc(8, sizeof(*status));
     snprintf(status, 8, "dwl %.1f", VERSION);
     pango_layout_set_text(bar->status.layout, status, strlen(status));
-- 
2.39.1


From f4f87b8d3c07750afca58b5a72c4ba7ef4d8f009 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 15:17:34 -0800
Subject: [PATCH 04/11] removed log message

---
 src/bar.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/bar.c b/src/bar.c
index 257ab91..403b4db 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -427,7 +427,6 @@ int bar_is_visible(Bar* bar) {
 }
 
 void bar_set_layout(Bar *bar, const char* text) {
-    _logf("'%s' '%d'\n", text, strlen(text));
     pango_layout_set_text(bar->layout.layout, text, strlen(text));
 }
 
-- 
2.39.1


From 0b910f943f7e3006068208acf18b08e2429ba1a6 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 15:33:47 -0800
Subject: [PATCH 05/11] Used component system for tags.

---
 src/bar.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 403b4db..61d68ff 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -328,13 +328,12 @@ Bar* bar_create(void) {
     pango_layout_set_text(bar->status.layout, status, strlen(status));
 
     for ( int i = 0; i < WL_ARRAY_LENGTH(&tags, char**); i++ ) { // Initalize the tags
-        PangoLayout* layout = pango_layout_new(bar->context);
+        BarComponent component = bar_component_create(bar->context, bar_font.description);
         char* name = *WL_ARRAY_AT(&tags, char**, i);
 
-        pango_layout_set_text(layout, name, strlen(name));
-        pango_layout_set_font_description(layout, bar_font.description);
+        pango_layout_set_text(component.layout, name, strlen(name));
 
-        Tag tag = { 0, 0, 0, layout };
+        Tag tag = { 0, 0, 0, component };
         bar->tags[i] = tag;
     }
 
-- 
2.39.1


From 373db2787c096e813c0391e798997f960ebfe4cf Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 17:16:02 -0800
Subject: [PATCH 06/11] removed logging stuff

---
 src/bar.c    |  2 --
 src/common.h |  5 -----
 src/main.c   | 28 ----------------------------
 3 files changed, 35 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 61d68ff..3d99f1d 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -482,9 +482,7 @@ void bar_click(Bar* bar, struct Monitor* monitor, int x, int y, uint32_t button)
 
     for (int i = 0; i < LENGTH(buttons); i++) {
         if (buttons[i].location == location && buttons[i].button == button) {
-            logln("found button");
             buttons[i].func(monitor, argp ? argp : &buttons[i].arg);
-            logln("after button function");
             return;
         }
     }
diff --git a/src/common.h b/src/common.h
index f42eee2..ddcfcfa 100644
--- a/src/common.h
+++ b/src/common.h
@@ -50,7 +50,6 @@ extern wl_display* display;
 extern wl_compositor* compositor;
 extern wl_shm* shm;
 extern zwlr_layer_shell_v1* shell;
-extern FILE* file;
 extern wl_array tags, layouts;
 
 struct Monitor;
@@ -74,10 +73,6 @@ typedef struct {
 void die(const char* fmt, ...);
 void* ecalloc(size_t amnt, size_t size);
 
-/* Logging functions */
-extern void logln(const char* str);
-extern void _logf(const char* fmt, ...);
-
 /*
  * User function definitions.
  * Usually used for when clicking buttons with a pointer.
diff --git a/src/main.c b/src/main.c
index 17b9354..f7f04f6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -170,8 +170,6 @@ static char* fifo_path;
 static struct sigaction sighandle;
 static struct sigaction child_handle;
 
-FILE* file;
-
 /*
  * So that the global handler knows that we can initialize an output.
  * Rather than just store it for when we have all of our globals.
@@ -486,22 +484,18 @@ void spawn(Monitor* monitor, const Arg *arg) {
 
 void layout(Monitor* monitor, const Arg* arg) {
   if (!arg->ui && monitor->layout > 0) {
-    logln("decrement");
     monitor->layout--;
   } else if (arg->ui && monitor->layout < WL_ARRAY_LENGTH(&layouts, char**)) {
-    logln("increment");
     monitor->layout++;
   } else {
     return;
   }
 
   zdwl_output_v1_set_layout(monitor->dwl_output, monitor->layout);
-  logln("layout");
 }
 
 void view(struct Monitor* monitor, const Arg* arg) {
   zdwl_output_v1_set_tags(monitor->dwl_output, arg->ui, 1);
-  logln("viewed");
 }
 
 void toggle_view(struct Monitor* monitor, const Arg* arg) {
@@ -698,9 +692,6 @@ void on_status(void) {
       goto done;
     }
 
-    fprintf(file, "'%s'", status);
-    fflush(file);
-
     Monitor *current_monitor;
     wl_list_for_each(current_monitor, &monitors, link) {
         bar_set_status(current_monitor->bar, status);
@@ -716,10 +707,6 @@ void on_status(void) {
 }
 
 void setup(void) {
-  file = fopen("log.txt", "w");
-  if (!file)
-    die("file");
-
   if (pipe(self_pipe) < 0)
     die("pipe");
 
@@ -816,8 +803,6 @@ void cleanup(void) {
     xdg_wm_base_destroy(base);
   if (shell)
     zwlr_layer_shell_v1_destroy(shell);
-  if (file)
-    fclose(file);
   if (display)
     wl_display_disconnect(display);
   if (fifo_path) {
@@ -887,16 +872,3 @@ void* ecalloc(size_t amnt, size_t size) {
 
   return p;
 }
-
-void _logf(const char *fmt, ...) {
-  va_list ap;
-  va_start(ap, fmt);
-  vfprintf(file, fmt, ap);
-  fflush(file);
-  va_end(ap);
-}
-
-void logln(const char* str) {
-    fprintf(file, "%s\n", str);
-    fflush(file);
-}
-- 
2.39.1


From e2acb66b1926234887d31c65e8d6c488a37fdb35 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 17:28:13 -0800
Subject: [PATCH 07/11] shortened some if statements

---
 src/bar.c  | 9 +++------
 src/main.c | 3 +--
 2 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 3d99f1d..30957d0 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -88,9 +88,8 @@ void layerSurface(void* data, zwlr_layer_surface_v1* _, uint32_t serial, uint32_
     zwlr_layer_surface_v1_ack_configure(bar->layer_surface, serial);
 
     if (bar->shm) {
-        if (bar->shm->width == width && bar->shm->height) {
+        if (bar->shm->width == width && bar->shm->height)
           return;
-        }
         shm_destroy(bar->shm);
     }
 
@@ -274,9 +273,8 @@ void bar_status_render(Bar* bar, cairo_t* painter, int* x) {
 }
 
 void bar_render(Bar* bar) {
-    if (!bar || !bar->shm) {
+    if (!bar || !bar->shm)
         return;
-    }
 
     int x = 0; /* Keep track of the cairo cursor */
     cairo_surface_t* image = cairo_image_surface_create_for_data(shm_data(bar->shm),
@@ -311,9 +309,8 @@ Bar* bar_create(void) {
     bar->floating = 0;
 
     bar->context = pango_font_map_create_context(pango_cairo_font_map_get_default());
-    if (!bar->context) {
+    if (!bar->context)
         die("pango context");
-    }
 
     if (!bar_font.description)
         bar_font = getFont();
diff --git a/src/main.c b/src/main.c
index f7f04f6..d710a2e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -601,9 +601,8 @@ void setupFifo(void) {
 }
 
 void update_monitor(Monitor* monitor) {
-  if (!monitor->visibilty) {
+  if (!monitor->visibilty)
     return;
-  }
 
   if (!bar_is_visible(monitor->bar)) {
     bar_show(monitor->bar, monitor->wl_output);
-- 
2.39.1


From 5b20fcfbe5a1df71ecd92aaf081f669cf9367549 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Tue, 21 Feb 2023 17:48:24 -0800
Subject: [PATCH 08/11] Shortened some statements

---
 src/bar.c  |  3 +--
 src/main.c | 16 ++++++----------
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/src/bar.c b/src/bar.c
index 30957d0..6a1f108 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -387,9 +387,8 @@ void bar_invalidate(Bar* bar) {
 }
 
 void bar_show(Bar* bar, wl_output* output) {
-    if (!bar || !output || bar_is_visible(bar)) {
+    if (!bar || !output || bar_is_visible(bar))
       return;
-    }
 
     bar->surface = wl_compositor_create_surface(compositor);
     bar->layer_surface = zwlr_layer_shell_v1_get_layer_surface(shell, bar->surface, output, ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM, "doom.dwl-bar");
diff --git a/src/main.c b/src/main.c
index d710a2e..6581299 100644
--- a/src/main.c
+++ b/src/main.c
@@ -351,13 +351,11 @@ void button(void *data, wl_pointer *pointer, uint32_t serial, uint32_t time,
 static void pointer_frame(void* data, wl_pointer* pointer) {
   Seat seat = *(Seat*)data;
   Monitor* monitor = seat.pointer->focused_monitor;
-  if (!monitor) {
+  if (!monitor)
     return;
-  }
 
-  for (int i = 0; i < seat.pointer->size; i++) {
+  for (int i = 0; i < seat.pointer->size; i++)
     bar_click(monitor->bar, monitor, seat.pointer->x, seat.pointer->y, seat.pointer->buttons[i]);
-  }
 
   free(seat.pointer->buttons);
   seat.pointer->buttons = NULL;
@@ -379,9 +377,9 @@ void capabilites(void* data, wl_seat* wl_seat, uint32_t capabilities) {
   if (seat->pointer && !has_pointer) {
     wl_pointer_release(seat->pointer->pointer);
     seat->pointer->focused_monitor = NULL;
-    if (seat->pointer->buttons) {
+    if (seat->pointer->buttons)
       free(seat->pointer->buttons);
-    }
+
     free(seat->pointer);
   }
 }
@@ -776,9 +774,8 @@ void run(void) {
         die("POLLNVAL");
 
       if (pollfd->fd == wl_display_fd) {
-        if ((pollfd->revents & POLLIN) && (wl_display_dispatch(display) < 0)) {
+        if ((pollfd->revents & POLLIN) && (wl_display_dispatch(display) < 0))
           die("wl_display_dispatch");
-        }
 
         if (pollfd->revents & POLLOUT) {
           pollfd->events = POLLIN;
@@ -865,9 +862,8 @@ void die(const char *fmt, ...) {
 void* ecalloc(size_t amnt, size_t size) {
   void *p;
 
-  if (!(p = calloc(amnt, size))) {
+  if (!(p = calloc(amnt, size)))
     die("calloc did not allocate");
-  }
 
   return p;
 }
-- 
2.39.1


From a316631eab690144c318a0ed8bf55c04c9da0010 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Wed, 22 Feb 2023 08:30:06 -0800
Subject: [PATCH 09/11] Fixed toggle_visibility.

---
 README.md    |  7 +++++++
 src/bar.c    |  4 ++++
 src/common.h | 10 +++++-----
 src/main.c   |  8 +++++---
 4 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/README.md b/README.md
index b5e2507..b4e16f4 100644
--- a/README.md
+++ b/README.md
@@ -5,6 +5,13 @@ I believe dwl-bar provides a more dwm-like experience out of the box than other
 
 Still in development. But should compile.
 
+## TODO
+ + [ ] Create a Makefile or some way (maybe just instructions like a command or build script) to build the program.
+    + [ ] Remove extraneous protcol files and move their generation to a Makefile with `wayland-scanner`.
+ + [ ] Move `config.h` to `config.def.h`, then require config.h to be made through the Makefile / build script.
+ + [ ] Create the ipc patch from the ipc branch and place it in the patches directory.
+ + [x] Test `toggle_visibilty` by adding some keybinds to dwl.
+
 ## Dependencies
 I'm not sure what the package names will be for your distrobution, so just make sure these are generally what you have.
  + pango
diff --git a/src/bar.c b/src/bar.c
index 6a1f108..b3569ff 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -411,6 +411,10 @@ void bar_hide(Bar* bar) {
     zwlr_layer_surface_v1_destroy(bar->layer_surface);
     wl_surface_destroy(bar->surface);
     shm_destroy(bar->shm);
+
+    bar->surface = NULL;
+    bar->layer_surface = NULL;
+    bar->shm = NULL;
 }
 
 int bar_is_visible(Bar* bar) {
diff --git a/src/common.h b/src/common.h
index ddcfcfa..27f669e 100644
--- a/src/common.h
+++ b/src/common.h
@@ -77,10 +77,10 @@ void* ecalloc(size_t amnt, size_t size);
  * User function definitions.
  * Usually used for when clicking buttons with a pointer.
  */
-extern void spawn(struct Monitor* monitor, const Arg* arg);
-extern void layout(struct Monitor* monitor, const Arg* arg);
-extern void view(struct Monitor* monitor, const Arg* arg);
-extern void toggle_view(struct Monitor* monitor, const Arg* arg);
-extern void tag(struct Monitor* monitor, const Arg* arg);
+void spawn(struct Monitor* monitor, const Arg* arg);
+void layout(struct Monitor* monitor, const Arg* arg);
+void view(struct Monitor* monitor, const Arg* arg);
+void toggle_view(struct Monitor* monitor, const Arg* arg);
+void tag(struct Monitor* monitor, const Arg* arg);
 
 #endif // COMMON_H_
diff --git a/src/main.c b/src/main.c
index 6581299..309368a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -242,8 +242,8 @@ void add_tag(void* data, zdwl_manager_v1* zdwl_manager_v1, const char* name) {
 
 void toggle_visibility(void* data, zdwl_output_v1* zdwl_output_v1) {
   Monitor* monitor = data;
-  monitor->visibilty = ~monitor->visibilty;
-  bar_hide(monitor->bar);
+  monitor->visibilty = 1-monitor->visibilty;
+  update_monitor(monitor);
 }
 
 void active(void* data, zdwl_output_v1* zdwl_output_v1, uint32_t active) {
@@ -599,8 +599,10 @@ void setupFifo(void) {
 }
 
 void update_monitor(Monitor* monitor) {
-  if (!monitor->visibilty)
+  if (!monitor->visibilty && bar_is_visible(monitor->bar)) {
+    bar_hide(monitor->bar);
     return;
+  }
 
   if (!bar_is_visible(monitor->bar)) {
     bar_show(monitor->bar, monitor->wl_output);
-- 
2.39.1


From 7d01a839de100e8283ff2d0fd122fd368aa372a2 Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Wed, 22 Feb 2023 22:14:02 -0800
Subject: [PATCH 10/11] Added make file stuff

---
 .gitignore                                    |    5 +
 Makefile                                      |   86 +
 README.md                                     |    7 -
 src/bar.c                                     |   11 +-
 src/bar.h                                     |    2 +-
 src/common.h                                  |    4 +-
 src/{config.h => config.def.h}                |    2 +-
 src/dwl-bar-ipc-unstable-v1-cliet-protocol.h  |  417 ---
 src/dwl-bar-ipc-unstable-v1-protocol.c        |   66 -
 src/main.c                                    |   15 +-
 ...-layer-shell-unstable-v1-client-protocol.h |  706 -----
 src/wlr-layer-shell-unstable-v1-protocol.c    |   93 -
 src/xdg-output-unstable-v1-client-protocol.h  |  411 ---
 src/xdg-output-unstable-v1-protocol.c         |   78 -
 src/xdg-shell-client-protocol.h               | 2280 -----------------
 src/xdg-shell-protocol.c                      |  183 --
 16 files changed, 103 insertions(+), 4263 deletions(-)
 create mode 100644 Makefile
 rename src/{config.h => config.def.h} (96%)
 delete mode 100644 src/dwl-bar-ipc-unstable-v1-cliet-protocol.h
 delete mode 100644 src/dwl-bar-ipc-unstable-v1-protocol.c
 delete mode 100644 src/wlr-layer-shell-unstable-v1-client-protocol.h
 delete mode 100644 src/wlr-layer-shell-unstable-v1-protocol.c
 delete mode 100644 src/xdg-output-unstable-v1-client-protocol.h
 delete mode 100644 src/xdg-output-unstable-v1-protocol.c
 delete mode 100644 src/xdg-shell-client-protocol.h
 delete mode 100644 src/xdg-shell-protocol.c

diff --git a/.gitignore b/.gitignore
index 971f1a3..c679520 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,8 @@ bar
 run
 compile_flags.txt
 log.txt
+config.h
+src/xdg-shell-protocol.h
+src/xdg-output-unstable-v1-protocol.h
+src/wlr-layer-shell-unstable-v1-protocol.h
+src/dwl-bar-ipc-unstable-v1-protocol.h
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..af5a37a
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,86 @@
+##
+# dwl-bar
+#
+# @file
+# @version 1.0
+.POSIX:
+.SUFFIXES:
+
+VERSION    = 1.0
+PKG_CONFIG = pkg-config
+
+#paths
+PREFIX = /usr/local
+MANDIR = $(PREFIX)/share/man
+
+# Compile flags
+CC 		  = gcc
+PKGS      = wayland-client wayland-cursor pangocairo
+BARCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(CFLAGS)
+BARLIBS   = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
+
+# Wayland-scanner
+WAYLAND_SCANNER   = `$(PKG_CONFIG) --variable=wayland_scanner wayland-scanner`
+WAYLAND_PROTOCOLS = `$(PKG_CONFIG) --variable=pkgdatadir wayland-protocols`
+
+srcdir := src
+
+all: dwl-bar
+dwl-bar: $(srcdir)/xdg-shell-protocol.o $(srcdir)/xdg-output-unstable-v1-protocol.o $(srcdir)/wlr-layer-shell-unstable-v1-protocol.o $(srcdir)/dwl-bar-ipc-unstable-v1-protocol.o $(srcdir)/main.c $(srcdir)/bar.c $(srcdir)/shm.c $(srcdir)/config.h
+	$(CC) $^ $(BARLIBS) $(BARCFLAGS) -o $@
+$(srcdir)/%.o: $(srcdir)/%.c $(srcdir)/%.h
+	$(CC) -c $< $(BARLIBS) $(BARCFLAGS) -o $@
+
+$(srcdir)/xdg-shell-protocol.h:
+	$(WAYLAND_SCANNER) client-header \
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+$(srcdir)/xdg-shell-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+
+$(srcdir)/xdg-output-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) client-header \
+		$(WAYLAND_PROTOCOLS)/unstable/xdg-output/xdg-output-unstable-v1.xml $@
+$(srcdir)/xdg-output-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		$(WAYLAND_PROTOCOLS)/unstable/xdg-output/xdg-output-unstable-v1.xml $@
+
+$(srcdir)/wlr-layer-shell-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) client-header \
+		protocols/wlr-layer-shell-unstable-v1.xml $@
+$(srcdir)/wlr-layer-shell-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/wlr-layer-shell-unstable-v1.xml $@
+
+$(srcdir)/dwl-bar-ipc-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) client-header \
+		protocols/dwl-bar-ipc-unstable-v1.xml $@
+$(srcdir)/dwl-bar-ipc-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/dwl-bar-ipc-unstable-v1.xml $@
+
+$(srcdir)/config.h:
+	cp src/config.def.h $@
+
+clean:
+	rm -f dwl-bar src/*.o src/*-protocol.*
+
+dist: clean
+	mkdir -p dwl-bar-$(VERSION)
+	cp -R LICENSE Makefile README.md src patches protocols \
+		dwl-bar-$(VERSION)
+	tar -caf dwl-bar-$(VERSION).tar.gz dwl-bar-$(VERSION)
+	rm -rf dwl-bar-$(VERSION)
+
+install: dwl-bar
+	mkdir -p $(PREFIX)/bin
+	cp -f dwl-bar $(PREFIX)/bin
+	chmod 755 $(PREFIX)/bin/dwl-bar
+	mkdir -p $(PREFIX)/man1
+	cp -f dwl-bar.1 $(MANDIR)/man1
+	chmod 644 $(MANDIR)/man1/dwl-bar.1
+
+uninstall:
+	rm -f $(PREFIX)/bin/dwl-bar $(MANDIR)/man1/dwl-bar.1
+
+# end
diff --git a/README.md b/README.md
index b4e16f4..b5e2507 100644
--- a/README.md
+++ b/README.md
@@ -5,13 +5,6 @@ I believe dwl-bar provides a more dwm-like experience out of the box than other
 
 Still in development. But should compile.
 
-## TODO
- + [ ] Create a Makefile or some way (maybe just instructions like a command or build script) to build the program.
-    + [ ] Remove extraneous protcol files and move their generation to a Makefile with `wayland-scanner`.
- + [ ] Move `config.h` to `config.def.h`, then require config.h to be made through the Makefile / build script.
- + [ ] Create the ipc patch from the ipc branch and place it in the patches directory.
- + [x] Test `toggle_visibilty` by adding some keybinds to dwl.
-
 ## Dependencies
 I'm not sure what the package names will be for your distrobution, so just make sure these are generally what you have.
  + pango
diff --git a/src/bar.c b/src/bar.c
index b3569ff..43ed226 100644
--- a/src/bar.c
+++ b/src/bar.c
@@ -5,20 +5,13 @@
 #include <wayland-client-protocol.h>
 
 #include <pango-1.0/pango/pangocairo.h>
-#include <wayland-util.h>
-#include "cairo-deprecated.h"
-#include "cairo.h"
-#include "pango/pango-context.h"
-#include "pango/pango-font.h"
-#include "pango/pango-layout.h"
-#include "pango/pango-types.h"
 
 #include "config.h"
 #include "bar.h"
 #include "common.h"
 #include "shm.h"
-#include "wlr-layer-shell-unstable-v1-client-protocol.h"
-#include "xdg-shell-client-protocol.h"
+#include "wlr-layer-shell-unstable-v1-protocol.h"
+#include "xdg-shell-protocol.h"
 
 typedef struct Font {
     PangoFontDescription* description;
diff --git a/src/bar.h b/src/bar.h
index 6581aec..8d4e24f 100644
--- a/src/bar.h
+++ b/src/bar.h
@@ -1,6 +1,6 @@
 #ifndef BAR_H_
 #define BAR_H_
-#include "wlr-layer-shell-unstable-v1-client-protocol.h"
+#include "wlr-layer-shell-unstable-v1-protocol.h"
 #include <stdint.h>
 #include <sys/types.h>
 #include <wayland-client-protocol.h>
diff --git a/src/common.h b/src/common.h
index 27f669e..cdbed54 100644
--- a/src/common.h
+++ b/src/common.h
@@ -1,7 +1,7 @@
 #ifndef COMMON_H_
 #define COMMON_H_
-#include "dwl-bar-ipc-unstable-v1-cliet-protocol.h"
-#include "xdg-output-unstable-v1-client-protocol.h"
+#include "dwl-bar-ipc-unstable-v1-protocol.h"
+#include "xdg-output-unstable-v1-protocol.h"
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/src/config.h b/src/config.def.h
similarity index 96%
rename from src/config.h
rename to src/config.def.h
index 0e6112d..81d17be 100644
--- a/src/config.h
+++ b/src/config.def.h
@@ -4,7 +4,7 @@
 #include <linux/input-event-codes.h>
 
 static const int bar_top = 1; /* Boolean value, non-zero is true. If not top then bottom */
-static const int status_on_active = 0; /* Display the status on active monitor only. If not then on all. */
+static const int status_on_active = 1; /* Display the status on active monitor only. If not then on all. */
 static const char* font = "Monospace 10";
 static const char* terminal[] = { "alacritty", NULL };
 
diff --git a/src/dwl-bar-ipc-unstable-v1-cliet-protocol.h b/src/dwl-bar-ipc-unstable-v1-cliet-protocol.h
deleted file mode 100644
index c39e619..0000000
--- a/src/dwl-bar-ipc-unstable-v1-cliet-protocol.h
+++ /dev/null
@@ -1,417 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-#ifndef DWL_BAR_IPC_UNSTABLE_V1_CLIENT_PROTOCOL_H
-#define DWL_BAR_IPC_UNSTABLE_V1_CLIENT_PROTOCOL_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "wayland-client.h"
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-/**
- * @page page_dwl_bar_ipc_unstable_v1 The dwl_bar_ipc_unstable_v1 protocol
- * inter-proccess-communication about dwl's state
- *
- * @section page_desc_dwl_bar_ipc_unstable_v1 Description
- *
- * This protocol allows clients to get updates from dwl and vice versa.
- *
- * Warning! This protocol is experimental and may make backward incompatible changes.
- *
- * @section page_ifaces_dwl_bar_ipc_unstable_v1 Interfaces
- * - @subpage page_iface_zdwl_manager_v1 - manage dwl state
- * - @subpage page_iface_zdwl_output_v1 - control dwl output
- */
-struct wl_output;
-struct zdwl_manager_v1;
-struct zdwl_output_v1;
-
-#ifndef ZDWL_MANAGER_V1_INTERFACE
-#define ZDWL_MANAGER_V1_INTERFACE
-/**
- * @page page_iface_zdwl_manager_v1 zdwl_manager_v1
- * @section page_iface_zdwl_manager_v1_desc Description
- *
- * This interface is exposed as a global in wl_registry.
- *
- * Clients can use this interface to get a dwl_output.
- * After binding the client will revieve dwl_manager.tag and dwl_manager.layout events.
- * The dwl_manager.tag and dwl_manager.layout events expose tags and layouts to the client.
- * @section page_iface_zdwl_manager_v1_api API
- * See @ref iface_zdwl_manager_v1.
- */
-/**
- * @defgroup iface_zdwl_manager_v1 The zdwl_manager_v1 interface
- *
- * This interface is exposed as a global in wl_registry.
- *
- * Clients can use this interface to get a dwl_output.
- * After binding the client will revieve dwl_manager.tag and dwl_manager.layout events.
- * The dwl_manager.tag and dwl_manager.layout events expose tags and layouts to the client.
- */
-extern const struct wl_interface zdwl_manager_v1_interface;
-#endif
-#ifndef ZDWL_OUTPUT_V1_INTERFACE
-#define ZDWL_OUTPUT_V1_INTERFACE
-/**
- * @page page_iface_zdwl_output_v1 zdwl_output_v1
- * @section page_iface_zdwl_output_v1_desc Description
- *
- * Observe and control a dwl output.
- *
- * Events are double-buffered:
- * Clients should cache events and redraw when a dwl_output.done event is sent.
- *
- * Request are not double-buffered:
- * The compositor will update immediately upon request.
- * @section page_iface_zdwl_output_v1_api API
- * See @ref iface_zdwl_output_v1.
- */
-/**
- * @defgroup iface_zdwl_output_v1 The zdwl_output_v1 interface
- *
- * Observe and control a dwl output.
- *
- * Events are double-buffered:
- * Clients should cache events and redraw when a dwl_output.done event is sent.
- *
- * Request are not double-buffered:
- * The compositor will update immediately upon request.
- */
-extern const struct wl_interface zdwl_output_v1_interface;
-#endif
-
-/**
- * @ingroup iface_zdwl_manager_v1
- * @struct zdwl_manager_v1_listener
- */
-struct zdwl_manager_v1_listener {
-	/**
-	 * Announces a tag
-	 *
-	 * This event is sent after binding. A roundtrip after binding
-	 * guarantees the client recieved all tags.
-	 */
-	void (*tag)(void *data,
-		    struct zdwl_manager_v1 *zdwl_manager_v1,
-		    const char *name);
-	/**
-	 * Announces a layout
-	 *
-	 * This event is sent after binding. A roundtrip after binding
-	 * guarantees the client recieved all layouts.
-	 */
-	void (*layout)(void *data,
-		       struct zdwl_manager_v1 *zdwl_manager_v1,
-		       const char *name);
-};
-
-/**
- * @ingroup iface_zdwl_manager_v1
- */
-static inline int
-zdwl_manager_v1_add_listener(struct zdwl_manager_v1 *zdwl_manager_v1,
-			     const struct zdwl_manager_v1_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) zdwl_manager_v1,
-				     (void (**)(void)) listener, data);
-}
-
-#define ZDWL_MANAGER_V1_RELEASE 0
-#define ZDWL_MANAGER_V1_GET_OUTPUT 1
-
-/**
- * @ingroup iface_zdwl_manager_v1
- */
-#define ZDWL_MANAGER_V1_TAG_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_manager_v1
- */
-#define ZDWL_MANAGER_V1_LAYOUT_SINCE_VERSION 1
-
-/**
- * @ingroup iface_zdwl_manager_v1
- */
-#define ZDWL_MANAGER_V1_RELEASE_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_manager_v1
- */
-#define ZDWL_MANAGER_V1_GET_OUTPUT_SINCE_VERSION 1
-
-/** @ingroup iface_zdwl_manager_v1 */
-static inline void
-zdwl_manager_v1_set_user_data(struct zdwl_manager_v1 *zdwl_manager_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zdwl_manager_v1, user_data);
-}
-
-/** @ingroup iface_zdwl_manager_v1 */
-static inline void *
-zdwl_manager_v1_get_user_data(struct zdwl_manager_v1 *zdwl_manager_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zdwl_manager_v1);
-}
-
-static inline uint32_t
-zdwl_manager_v1_get_version(struct zdwl_manager_v1 *zdwl_manager_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zdwl_manager_v1);
-}
-
-/** @ingroup iface_zdwl_manager_v1 */
-static inline void
-zdwl_manager_v1_destroy(struct zdwl_manager_v1 *zdwl_manager_v1)
-{
-	wl_proxy_destroy((struct wl_proxy *) zdwl_manager_v1);
-}
-
-/**
- * @ingroup iface_zdwl_manager_v1
- *
- * Indicates that the client will not the dwl_manager object anymore.
- * Objects created through this instance are not affected.
- */
-static inline void
-zdwl_manager_v1_release(struct zdwl_manager_v1 *zdwl_manager_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zdwl_manager_v1,
-			 ZDWL_MANAGER_V1_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) zdwl_manager_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_zdwl_manager_v1
- *
- * Get a dwl_output for the specified wl_output.
- */
-static inline struct zdwl_output_v1 *
-zdwl_manager_v1_get_output(struct zdwl_manager_v1 *zdwl_manager_v1, struct wl_output *output)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) zdwl_manager_v1,
-			 ZDWL_MANAGER_V1_GET_OUTPUT, &zdwl_output_v1_interface, wl_proxy_get_version((struct wl_proxy *) zdwl_manager_v1), 0, NULL, output);
-
-	return (struct zdwl_output_v1 *) id;
-}
-
-#ifndef ZDWL_OUTPUT_V1_TAG_STATE_ENUM
-#define ZDWL_OUTPUT_V1_TAG_STATE_ENUM
-enum zdwl_output_v1_tag_state {
-	/**
-	 * no state
-	 */
-	ZDWL_OUTPUT_V1_TAG_STATE_NONE = 0,
-	/**
-	 * tag is active
-	 */
-	ZDWL_OUTPUT_V1_TAG_STATE_ACTIVE = 1,
-	/**
-	 * tag has at least one urgent client
-	 */
-	ZDWL_OUTPUT_V1_TAG_STATE_URGENT = 2,
-};
-#endif /* ZDWL_OUTPUT_V1_TAG_STATE_ENUM */
-
-/**
- * @ingroup iface_zdwl_output_v1
- * @struct zdwl_output_v1_listener
- */
-struct zdwl_output_v1_listener {
-	/**
-	 * Toggle client visibilty
-	 *
-	 * Indicates the client should hide or show themselves. If the
-	 * client is visible then hide, if hidden then show.
-	 */
-	void (*toggle_visibility)(void *data,
-				  struct zdwl_output_v1 *zdwl_output_v1);
-	/**
-	 * Update the selected output.
-	 *
-	 * Indicates if the output is active. Zero is invalid, nonzero is
-	 * valid.
-	 */
-	void (*active)(void *data,
-		       struct zdwl_output_v1 *zdwl_output_v1,
-		       uint32_t active);
-	/**
-	 * Update the state of a tag.
-	 *
-	 * Indicates that a tag has been updated.
-	 * @param tag Index of the tag
-	 * @param state The state of the tag.
-	 * @param clients The number of clients in the tag.
-	 * @param focused If there is a focused client. Nonzero being valid, zero being invalid.
-	 */
-	void (*tag)(void *data,
-		    struct zdwl_output_v1 *zdwl_output_v1,
-		    uint32_t tag,
-		    uint32_t state,
-		    uint32_t clients,
-		    uint32_t focused);
-	/**
-	 * Update the layout.
-	 *
-	 * Indicates a new layout is selected.
-	 * @param layout Index of the layout.
-	 */
-	void (*layout)(void *data,
-		       struct zdwl_output_v1 *zdwl_output_v1,
-		       uint32_t layout);
-	/**
-	 * Update the title.
-	 *
-	 * Indicates the title has changed.
-	 * @param title The new title name.
-	 */
-	void (*title)(void *data,
-		      struct zdwl_output_v1 *zdwl_output_v1,
-		      const char *title);
-	/**
-	 * The update sequence is done.
-	 *
-	 * Indicates that a sequence of status updates have finished and
-	 * the client should redraw.
-	 */
-	void (*frame)(void *data,
-		      struct zdwl_output_v1 *zdwl_output_v1);
-};
-
-/**
- * @ingroup iface_zdwl_output_v1
- */
-static inline int
-zdwl_output_v1_add_listener(struct zdwl_output_v1 *zdwl_output_v1,
-			    const struct zdwl_output_v1_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) zdwl_output_v1,
-				     (void (**)(void)) listener, data);
-}
-
-#define ZDWL_OUTPUT_V1_RELEASE 0
-#define ZDWL_OUTPUT_V1_SET_LAYOUT 1
-#define ZDWL_OUTPUT_V1_SET_TAGS 2
-#define ZDWL_OUTPUT_V1_SET_CLIENT_TAGS 3
-
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_TOGGLE_VISIBILITY_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_ACTIVE_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_TAG_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_LAYOUT_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_TITLE_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_FRAME_SINCE_VERSION 1
-
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_RELEASE_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_SET_LAYOUT_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_SET_TAGS_SINCE_VERSION 1
-/**
- * @ingroup iface_zdwl_output_v1
- */
-#define ZDWL_OUTPUT_V1_SET_CLIENT_TAGS_SINCE_VERSION 1
-
-/** @ingroup iface_zdwl_output_v1 */
-static inline void
-zdwl_output_v1_set_user_data(struct zdwl_output_v1 *zdwl_output_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zdwl_output_v1, user_data);
-}
-
-/** @ingroup iface_zdwl_output_v1 */
-static inline void *
-zdwl_output_v1_get_user_data(struct zdwl_output_v1 *zdwl_output_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zdwl_output_v1);
-}
-
-static inline uint32_t
-zdwl_output_v1_get_version(struct zdwl_output_v1 *zdwl_output_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zdwl_output_v1);
-}
-
-/** @ingroup iface_zdwl_output_v1 */
-static inline void
-zdwl_output_v1_destroy(struct zdwl_output_v1 *zdwl_output_v1)
-{
-	wl_proxy_destroy((struct wl_proxy *) zdwl_output_v1);
-}
-
-/**
- * @ingroup iface_zdwl_output_v1
- *
- * Indicates to that the client no longer needs this dwl_output.
- */
-static inline void
-zdwl_output_v1_release(struct zdwl_output_v1 *zdwl_output_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zdwl_output_v1,
-			 ZDWL_OUTPUT_V1_RELEASE, NULL, wl_proxy_get_version((struct wl_proxy *) zdwl_output_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_zdwl_output_v1
- */
-static inline void
-zdwl_output_v1_set_layout(struct zdwl_output_v1 *zdwl_output_v1, uint32_t index)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zdwl_output_v1,
-			 ZDWL_OUTPUT_V1_SET_LAYOUT, NULL, wl_proxy_get_version((struct wl_proxy *) zdwl_output_v1), 0, index);
-}
-
-/**
- * @ingroup iface_zdwl_output_v1
- */
-static inline void
-zdwl_output_v1_set_tags(struct zdwl_output_v1 *zdwl_output_v1, uint32_t tagmask, uint32_t toggle_tagset)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zdwl_output_v1,
-			 ZDWL_OUTPUT_V1_SET_TAGS, NULL, wl_proxy_get_version((struct wl_proxy *) zdwl_output_v1), 0, tagmask, toggle_tagset);
-}
-
-/**
- * @ingroup iface_zdwl_output_v1
- *
- * The tags are updated as follows:
- * new_tags = (current_tags AND and_tags) XOR xor_tags
- */
-static inline void
-zdwl_output_v1_set_client_tags(struct zdwl_output_v1 *zdwl_output_v1, uint32_t and_tags, uint32_t xor_tags)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zdwl_output_v1,
-			 ZDWL_OUTPUT_V1_SET_CLIENT_TAGS, NULL, wl_proxy_get_version((struct wl_proxy *) zdwl_output_v1), 0, and_tags, xor_tags);
-}
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/dwl-bar-ipc-unstable-v1-protocol.c b/src/dwl-bar-ipc-unstable-v1-protocol.c
deleted file mode 100644
index c563b6f..0000000
--- a/src/dwl-bar-ipc-unstable-v1-protocol.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-#include <stdlib.h>
-#include <stdint.h>
-#include "wayland-util.h"
-
-#ifndef __has_attribute
-# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
-#endif
-
-#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
-#define WL_PRIVATE __attribute__ ((visibility("hidden")))
-#else
-#define WL_PRIVATE
-#endif
-
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface zdwl_output_v1_interface;
-
-static const struct wl_interface *dwl_bar_ipc_unstable_v1_types[] = {
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	&zdwl_output_v1_interface,
-	&wl_output_interface,
-};
-
-static const struct wl_message zdwl_manager_v1_requests[] = {
-	{ "release", "", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "get_output", "no", dwl_bar_ipc_unstable_v1_types + 4 },
-};
-
-static const struct wl_message zdwl_manager_v1_events[] = {
-	{ "tag", "s", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "layout", "s", dwl_bar_ipc_unstable_v1_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface zdwl_manager_v1_interface = {
-	"zdwl_manager_v1", 1,
-	2, zdwl_manager_v1_requests,
-	2, zdwl_manager_v1_events,
-};
-
-static const struct wl_message zdwl_output_v1_requests[] = {
-	{ "release", "", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "set_layout", "u", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "set_tags", "uu", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "set_client_tags", "uu", dwl_bar_ipc_unstable_v1_types + 0 },
-};
-
-static const struct wl_message zdwl_output_v1_events[] = {
-	{ "toggle_visibility", "", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "active", "u", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "tag", "uuuu", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "layout", "u", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "title", "s", dwl_bar_ipc_unstable_v1_types + 0 },
-	{ "frame", "", dwl_bar_ipc_unstable_v1_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface zdwl_output_v1_interface = {
-	"zdwl_output_v1", 1,
-	4, zdwl_output_v1_requests,
-	6, zdwl_output_v1_events,
-};
-
diff --git a/src/main.c b/src/main.c
index 309368a..f935f5f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,13 +1,11 @@
-#include <asm-generic/errno-base.h>
-#include <math.h>
-#include <stdarg.h>
-#include <stddef.h>
 #include <wayland-client-core.h>
 #include <wayland-client-protocol.h>
 #include <wayland-client.h>
 #include <wayland-cursor.h>
 #include <wayland-util.h>
 
+#include <stdarg.h>
+#include <stddef.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
@@ -22,14 +20,13 @@
 #include <sys/stat.h>
 
 #include "bar.h"
-#include "cairo.h"
 #include "common.h"
 #include "config.h"
 #include "shm.h"
-#include "dwl-bar-ipc-unstable-v1-cliet-protocol.h"
-#include "wlr-layer-shell-unstable-v1-client-protocol.h"
-#include "xdg-output-unstable-v1-client-protocol.h"
-#include "xdg-shell-client-protocol.h"
+#include "dwl-bar-ipc-unstable-v1-protocol.h"
+#include "wlr-layer-shell-unstable-v1-protocol.h"
+#include "xdg-output-unstable-v1-protocol.h"
+#include "xdg-shell-protocol.h"
 
 /*
  * When checking to see if two strings are the same with strcmp,
diff --git a/src/wlr-layer-shell-unstable-v1-client-protocol.h b/src/wlr-layer-shell-unstable-v1-client-protocol.h
deleted file mode 100644
index 6cbe380..0000000
--- a/src/wlr-layer-shell-unstable-v1-client-protocol.h
+++ /dev/null
@@ -1,706 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-#ifndef WLR_LAYER_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H
-#define WLR_LAYER_SHELL_UNSTABLE_V1_CLIENT_PROTOCOL_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "wayland-client.h"
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-/**
- * @page page_wlr_layer_shell_unstable_v1 The wlr_layer_shell_unstable_v1 protocol
- * @section page_ifaces_wlr_layer_shell_unstable_v1 Interfaces
- * - @subpage page_iface_zwlr_layer_shell_v1 - create surfaces that are layers of the desktop
- * - @subpage page_iface_zwlr_layer_surface_v1 - layer metadata interface
- * @section page_copyright_wlr_layer_shell_unstable_v1 Copyright
- * <pre>
- *
- * Copyright  2017 Drew DeVault
- *
- * Permission to use, copy, modify, distribute, and sell this
- * software and its documentation for any purpose is hereby granted
- * without fee, provided that the above copyright notice appear in
- * all copies and that both that copyright notice and this permission
- * notice appear in supporting documentation, and that the name of
- * the copyright holders not be used in advertising or publicity
- * pertaining to distribution of the software without specific,
- * written prior permission.  The copyright holders make no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
- * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
- * THIS SOFTWARE.
- * </pre>
- */
-struct wl_output;
-struct wl_surface;
-struct xdg_popup;
-struct zwlr_layer_shell_v1;
-struct zwlr_layer_surface_v1;
-
-#ifndef ZWLR_LAYER_SHELL_V1_INTERFACE
-#define ZWLR_LAYER_SHELL_V1_INTERFACE
-/**
- * @page page_iface_zwlr_layer_shell_v1 zwlr_layer_shell_v1
- * @section page_iface_zwlr_layer_shell_v1_desc Description
- *
- * Clients can use this interface to assign the surface_layer role to
- * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
- * rendered with a defined z-depth respective to each other. They may also be
- * anchored to the edges and corners of a screen and specify input handling
- * semantics. This interface should be suitable for the implementation of
- * many desktop shell components, and a broad number of other applications
- * that interact with the desktop.
- * @section page_iface_zwlr_layer_shell_v1_api API
- * See @ref iface_zwlr_layer_shell_v1.
- */
-/**
- * @defgroup iface_zwlr_layer_shell_v1 The zwlr_layer_shell_v1 interface
- *
- * Clients can use this interface to assign the surface_layer role to
- * wl_surfaces. Such surfaces are assigned to a "layer" of the output and
- * rendered with a defined z-depth respective to each other. They may also be
- * anchored to the edges and corners of a screen and specify input handling
- * semantics. This interface should be suitable for the implementation of
- * many desktop shell components, and a broad number of other applications
- * that interact with the desktop.
- */
-extern const struct wl_interface zwlr_layer_shell_v1_interface;
-#endif
-#ifndef ZWLR_LAYER_SURFACE_V1_INTERFACE
-#define ZWLR_LAYER_SURFACE_V1_INTERFACE
-/**
- * @page page_iface_zwlr_layer_surface_v1 zwlr_layer_surface_v1
- * @section page_iface_zwlr_layer_surface_v1_desc Description
- *
- * An interface that may be implemented by a wl_surface, for surfaces that
- * are designed to be rendered as a layer of a stacked desktop-like
- * environment.
- *
- * Layer surface state (layer, size, anchor, exclusive zone,
- * margin, interactivity) is double-buffered, and will be applied at the
- * time wl_surface.commit of the corresponding wl_surface is called.
- *
- * Attaching a null buffer to a layer surface unmaps it.
- *
- * Unmapping a layer_surface means that the surface cannot be shown by the
- * compositor until it is explicitly mapped again. The layer_surface
- * returns to the state it had right after layer_shell.get_layer_surface.
- * The client can re-map the surface by performing a commit without any
- * buffer attached, waiting for a configure event and handling it as usual.
- * @section page_iface_zwlr_layer_surface_v1_api API
- * See @ref iface_zwlr_layer_surface_v1.
- */
-/**
- * @defgroup iface_zwlr_layer_surface_v1 The zwlr_layer_surface_v1 interface
- *
- * An interface that may be implemented by a wl_surface, for surfaces that
- * are designed to be rendered as a layer of a stacked desktop-like
- * environment.
- *
- * Layer surface state (layer, size, anchor, exclusive zone,
- * margin, interactivity) is double-buffered, and will be applied at the
- * time wl_surface.commit of the corresponding wl_surface is called.
- *
- * Attaching a null buffer to a layer surface unmaps it.
- *
- * Unmapping a layer_surface means that the surface cannot be shown by the
- * compositor until it is explicitly mapped again. The layer_surface
- * returns to the state it had right after layer_shell.get_layer_surface.
- * The client can re-map the surface by performing a commit without any
- * buffer attached, waiting for a configure event and handling it as usual.
- */
-extern const struct wl_interface zwlr_layer_surface_v1_interface;
-#endif
-
-#ifndef ZWLR_LAYER_SHELL_V1_ERROR_ENUM
-#define ZWLR_LAYER_SHELL_V1_ERROR_ENUM
-enum zwlr_layer_shell_v1_error {
-	/**
-	 * wl_surface has another role
-	 */
-	ZWLR_LAYER_SHELL_V1_ERROR_ROLE = 0,
-	/**
-	 * layer value is invalid
-	 */
-	ZWLR_LAYER_SHELL_V1_ERROR_INVALID_LAYER = 1,
-	/**
-	 * wl_surface has a buffer attached or committed
-	 */
-	ZWLR_LAYER_SHELL_V1_ERROR_ALREADY_CONSTRUCTED = 2,
-};
-#endif /* ZWLR_LAYER_SHELL_V1_ERROR_ENUM */
-
-#ifndef ZWLR_LAYER_SHELL_V1_LAYER_ENUM
-#define ZWLR_LAYER_SHELL_V1_LAYER_ENUM
-/**
- * @ingroup iface_zwlr_layer_shell_v1
- * available layers for surfaces
- *
- * These values indicate which layers a surface can be rendered in. They
- * are ordered by z depth, bottom-most first. Traditional shell surfaces
- * will typically be rendered between the bottom and top layers.
- * Fullscreen shell surfaces are typically rendered at the top layer.
- * Multiple surfaces can share a single layer, and ordering within a
- * single layer is undefined.
- */
-enum zwlr_layer_shell_v1_layer {
-	ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND = 0,
-	ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM = 1,
-	ZWLR_LAYER_SHELL_V1_LAYER_TOP = 2,
-	ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY = 3,
-};
-#endif /* ZWLR_LAYER_SHELL_V1_LAYER_ENUM */
-
-#define ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE 0
-#define ZWLR_LAYER_SHELL_V1_DESTROY 1
-
-
-/**
- * @ingroup iface_zwlr_layer_shell_v1
- */
-#define ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_shell_v1
- */
-#define ZWLR_LAYER_SHELL_V1_DESTROY_SINCE_VERSION 3
-
-/** @ingroup iface_zwlr_layer_shell_v1 */
-static inline void
-zwlr_layer_shell_v1_set_user_data(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zwlr_layer_shell_v1, user_data);
-}
-
-/** @ingroup iface_zwlr_layer_shell_v1 */
-static inline void *
-zwlr_layer_shell_v1_get_user_data(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zwlr_layer_shell_v1);
-}
-
-static inline uint32_t
-zwlr_layer_shell_v1_get_version(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1);
-}
-
-/**
- * @ingroup iface_zwlr_layer_shell_v1
- *
- * Create a layer surface for an existing surface. This assigns the role of
- * layer_surface, or raises a protocol error if another role is already
- * assigned.
- *
- * Creating a layer surface from a wl_surface which has a buffer attached
- * or committed is a client error, and any attempts by a client to attach
- * or manipulate a buffer prior to the first layer_surface.configure call
- * must also be treated as errors.
- *
- * After creating a layer_surface object and setting it up, the client
- * must perform an initial commit without any buffer attached.
- * The compositor will reply with a layer_surface.configure event.
- * The client must acknowledge it and is then allowed to attach a buffer
- * to map the surface.
- *
- * You may pass NULL for output to allow the compositor to decide which
- * output to use. Generally this will be the one that the user most
- * recently interacted with.
- *
- * Clients can specify a namespace that defines the purpose of the layer
- * surface.
- */
-static inline struct zwlr_layer_surface_v1 *
-zwlr_layer_shell_v1_get_layer_surface(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1, struct wl_surface *surface, struct wl_output *output, uint32_t layer, const char *name_space)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_shell_v1,
-			 ZWLR_LAYER_SHELL_V1_GET_LAYER_SURFACE, &zwlr_layer_surface_v1_interface, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1), 0, NULL, surface, output, layer, name_space);
-
-	return (struct zwlr_layer_surface_v1 *) id;
-}
-
-/**
- * @ingroup iface_zwlr_layer_shell_v1
- *
- * This request indicates that the client will not use the layer_shell
- * object any more. Objects that have been created through this instance
- * are not affected.
- */
-static inline void
-zwlr_layer_shell_v1_destroy(struct zwlr_layer_shell_v1 *zwlr_layer_shell_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_shell_v1,
-			 ZWLR_LAYER_SHELL_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_shell_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-#ifndef ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
-#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- * types of keyboard interaction possible for a layer shell surface
- *
- * Types of keyboard interaction possible for layer shell surfaces. The
- * rationale for this is twofold: (1) some applications are not interested
- * in keyboard events and not allowing them to be focused can improve the
- * desktop experience; (2) some applications will want to take exclusive
- * keyboard focus.
- */
-enum zwlr_layer_surface_v1_keyboard_interactivity {
-	/**
-	 * no keyboard focus is possible
-	 *
-	 * This value indicates that this surface is not interested in
-	 * keyboard events and the compositor should never assign it the
-	 * keyboard focus.
-	 *
-	 * This is the default value, set for newly created layer shell
-	 * surfaces.
-	 *
-	 * This is useful for e.g. desktop widgets that display information
-	 * or only have interaction with non-keyboard input devices.
-	 */
-	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_NONE = 0,
-	/**
-	 * request exclusive keyboard focus
-	 *
-	 * Request exclusive keyboard focus if this surface is above the
-	 * shell surface layer.
-	 *
-	 * For the top and overlay layers, the seat will always give
-	 * exclusive keyboard focus to the top-most layer which has
-	 * keyboard interactivity set to exclusive. If this layer contains
-	 * multiple surfaces with keyboard interactivity set to exclusive,
-	 * the compositor determines the one receiving keyboard events in
-	 * an implementation- defined manner. In this case, no guarantee is
-	 * made when this surface will receive keyboard focus (if ever).
-	 *
-	 * For the bottom and background layers, the compositor is allowed
-	 * to use normal focus semantics.
-	 *
-	 * This setting is mainly intended for applications that need to
-	 * ensure they receive all keyboard events, such as a lock screen
-	 * or a password prompt.
-	 */
-	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_EXCLUSIVE = 1,
-	/**
-	 * request regular keyboard focus semantics
-	 *
-	 * This requests the compositor to allow this surface to be
-	 * focused and unfocused by the user in an implementation-defined
-	 * manner. The user should be able to unfocus this surface even
-	 * regardless of the layer it is on.
-	 *
-	 * Typically, the compositor will want to use its normal mechanism
-	 * to manage keyboard focus between layer shell surfaces with this
-	 * setting and regular toplevels on the desktop layer (e.g. click
-	 * to focus). Nevertheless, it is possible for a compositor to
-	 * require a special interaction to focus or unfocus layer shell
-	 * surfaces (e.g. requiring a click even if focus follows the mouse
-	 * normally, or providing a keybinding to switch focus between
-	 * layers).
-	 *
-	 * This setting is mainly intended for desktop shell components
-	 * (e.g. panels) that allow keyboard interaction. Using this option
-	 * can allow implementing a desktop shell that can be fully usable
-	 * without the mouse.
-	 * @since 4
-	 */
-	ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND = 2,
-};
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND_SINCE_VERSION 4
-#endif /* ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ENUM */
-
-#ifndef ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
-#define ZWLR_LAYER_SURFACE_V1_ERROR_ENUM
-enum zwlr_layer_surface_v1_error {
-	/**
-	 * provided surface state is invalid
-	 */
-	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SURFACE_STATE = 0,
-	/**
-	 * size is invalid
-	 */
-	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_SIZE = 1,
-	/**
-	 * anchor bitfield is invalid
-	 */
-	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_ANCHOR = 2,
-	/**
-	 * keyboard interactivity is invalid
-	 */
-	ZWLR_LAYER_SURFACE_V1_ERROR_INVALID_KEYBOARD_INTERACTIVITY = 3,
-};
-#endif /* ZWLR_LAYER_SURFACE_V1_ERROR_ENUM */
-
-#ifndef ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
-#define ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM
-enum zwlr_layer_surface_v1_anchor {
-	/**
-	 * the top edge of the anchor rectangle
-	 */
-	ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP = 1,
-	/**
-	 * the bottom edge of the anchor rectangle
-	 */
-	ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM = 2,
-	/**
-	 * the left edge of the anchor rectangle
-	 */
-	ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT = 4,
-	/**
-	 * the right edge of the anchor rectangle
-	 */
-	ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT = 8,
-};
-#endif /* ZWLR_LAYER_SURFACE_V1_ANCHOR_ENUM */
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- * @struct zwlr_layer_surface_v1_listener
- */
-struct zwlr_layer_surface_v1_listener {
-	/**
-	 * suggest a surface change
-	 *
-	 * The configure event asks the client to resize its surface.
-	 *
-	 * Clients should arrange their surface for the new states, and
-	 * then send an ack_configure request with the serial sent in this
-	 * configure event at some point before committing the new surface.
-	 *
-	 * The client is free to dismiss all but the last configure event
-	 * it received.
-	 *
-	 * The width and height arguments specify the size of the window in
-	 * surface-local coordinates.
-	 *
-	 * The size is a hint, in the sense that the client is free to
-	 * ignore it if it doesn't resize, pick a smaller size (to satisfy
-	 * aspect ratio or resize in steps of NxM pixels). If the client
-	 * picks a smaller size and is anchored to two opposite anchors
-	 * (e.g. 'top' and 'bottom'), the surface will be centered on this
-	 * axis.
-	 *
-	 * If the width or height arguments are zero, it means the client
-	 * should decide its own window dimension.
-	 */
-	void (*configure)(void *data,
-			  struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1,
-			  uint32_t serial,
-			  uint32_t width,
-			  uint32_t height);
-	/**
-	 * surface should be closed
-	 *
-	 * The closed event is sent by the compositor when the surface
-	 * will no longer be shown. The output may have been destroyed or
-	 * the user may have asked for it to be removed. Further changes to
-	 * the surface will be ignored. The client should destroy the
-	 * resource after receiving this event, and create a new surface if
-	 * they so choose.
-	 */
-	void (*closed)(void *data,
-		       struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1);
-};
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-static inline int
-zwlr_layer_surface_v1_add_listener(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1,
-				   const struct zwlr_layer_surface_v1_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) zwlr_layer_surface_v1,
-				     (void (**)(void)) listener, data);
-}
-
-#define ZWLR_LAYER_SURFACE_V1_SET_SIZE 0
-#define ZWLR_LAYER_SURFACE_V1_SET_ANCHOR 1
-#define ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE 2
-#define ZWLR_LAYER_SURFACE_V1_SET_MARGIN 3
-#define ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY 4
-#define ZWLR_LAYER_SURFACE_V1_GET_POPUP 5
-#define ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE 6
-#define ZWLR_LAYER_SURFACE_V1_DESTROY 7
-#define ZWLR_LAYER_SURFACE_V1_SET_LAYER 8
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_CONFIGURE_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_CLOSED_SINCE_VERSION 1
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_SIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_ANCHOR_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_MARGIN_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_GET_POPUP_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- */
-#define ZWLR_LAYER_SURFACE_V1_SET_LAYER_SINCE_VERSION 2
-
-/** @ingroup iface_zwlr_layer_surface_v1 */
-static inline void
-zwlr_layer_surface_v1_set_user_data(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zwlr_layer_surface_v1, user_data);
-}
-
-/** @ingroup iface_zwlr_layer_surface_v1 */
-static inline void *
-zwlr_layer_surface_v1_get_user_data(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zwlr_layer_surface_v1);
-}
-
-static inline uint32_t
-zwlr_layer_surface_v1_get_version(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Sets the size of the surface in surface-local coordinates. The
- * compositor will display the surface centered with respect to its
- * anchors.
- *
- * If you pass 0 for either value, the compositor will assign it and
- * inform you of the assignment in the configure event. You must set your
- * anchor to opposite edges in the dimensions you omit; not doing so is a
- * protocol error. Both values are 0 by default.
- *
- * Size is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_size(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t width, uint32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, width, height);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Requests that the compositor anchor the surface to the specified edges
- * and corners. If two orthogonal edges are specified (e.g. 'top' and
- * 'left'), then the anchor point will be the intersection of the edges
- * (e.g. the top left corner of the output); otherwise the anchor point
- * will be centered on that edge, or in the center if none is specified.
- *
- * Anchor is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_anchor(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t anchor)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, anchor);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Requests that the compositor avoids occluding an area with other
- * surfaces. The compositor's use of this information is
- * implementation-dependent - do not assume that this region will not
- * actually be occluded.
- *
- * A positive value is only meaningful if the surface is anchored to one
- * edge or an edge and both perpendicular edges. If the surface is not
- * anchored, anchored to only two perpendicular edges (a corner), anchored
- * to only two parallel edges or anchored to all edges, a positive value
- * will be treated the same as zero.
- *
- * A positive zone is the distance from the edge in surface-local
- * coordinates to consider exclusive.
- *
- * Surfaces that do not wish to have an exclusive zone may instead specify
- * how they should interact with surfaces that do. If set to zero, the
- * surface indicates that it would like to be moved to avoid occluding
- * surfaces with a positive exclusive zone. If set to -1, the surface
- * indicates that it would not like to be moved to accommodate for other
- * surfaces, and the compositor should extend it all the way to the edges
- * it is anchored to.
- *
- * For example, a panel might set its exclusive zone to 10, so that
- * maximized shell surfaces are not shown on top of it. A notification
- * might set its exclusive zone to 0, so that it is moved to avoid
- * occluding the panel, but shell surfaces are shown underneath it. A
- * wallpaper or lock screen might set their exclusive zone to -1, so that
- * they stretch below or over the panel.
- *
- * The default value is 0.
- *
- * Exclusive zone is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_exclusive_zone(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, int32_t zone)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_EXCLUSIVE_ZONE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, zone);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Requests that the surface be placed some distance away from the anchor
- * point on the output, in surface-local coordinates. Setting this value
- * for edges you are not anchored to has no effect.
- *
- * The exclusive zone includes the margin.
- *
- * Margin is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_margin(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, int32_t top, int32_t right, int32_t bottom, int32_t left)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_MARGIN, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, top, right, bottom, left);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Set how keyboard events are delivered to this surface. By default,
- * layer shell surfaces do not receive keyboard events; this request can
- * be used to change this.
- *
- * This setting is inherited by child surfaces set by the get_popup
- * request.
- *
- * Layer surfaces receive pointer, touch, and tablet events normally. If
- * you do not want to receive them, set the input region on your surface
- * to an empty region.
- *
- * Keyboard interactivity is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_keyboard_interactivity(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t keyboard_interactivity)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_KEYBOARD_INTERACTIVITY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, keyboard_interactivity);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * This assigns an xdg_popup's parent to this layer_surface.  This popup
- * should have been created via xdg_surface::get_popup with the parent set
- * to NULL, and this request must be invoked before committing the popup's
- * initial state.
- *
- * See the documentation of xdg_popup for more details about what an
- * xdg_popup is and how it is used.
- */
-static inline void
-zwlr_layer_surface_v1_get_popup(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, struct xdg_popup *popup)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_GET_POPUP, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, popup);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * When a configure event is received, if a client commits the
- * surface in response to the configure event, then the client
- * must make an ack_configure request sometime before the commit
- * request, passing along the serial of the configure event.
- *
- * If the client receives multiple configure events before it
- * can respond to one, it only has to ack the last configure event.
- *
- * A client is not required to commit immediately after sending
- * an ack_configure request - it may even ack_configure several times
- * before its next surface commit.
- *
- * A client may send multiple ack_configure requests before committing, but
- * only the last request sent before a commit indicates which configure
- * event the client really is responding to.
- */
-static inline void
-zwlr_layer_surface_v1_ack_configure(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, serial);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * This request destroys the layer surface.
- */
-static inline void
-zwlr_layer_surface_v1_destroy(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_zwlr_layer_surface_v1
- *
- * Change the layer that the surface is rendered on.
- *
- * Layer is double-buffered, see wl_surface.commit.
- */
-static inline void
-zwlr_layer_surface_v1_set_layer(struct zwlr_layer_surface_v1 *zwlr_layer_surface_v1, uint32_t layer)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zwlr_layer_surface_v1,
-			 ZWLR_LAYER_SURFACE_V1_SET_LAYER, NULL, wl_proxy_get_version((struct wl_proxy *) zwlr_layer_surface_v1), 0, layer);
-}
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/wlr-layer-shell-unstable-v1-protocol.c b/src/wlr-layer-shell-unstable-v1-protocol.c
deleted file mode 100644
index 31832f4..0000000
--- a/src/wlr-layer-shell-unstable-v1-protocol.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-/*
- * Copyright  2017 Drew DeVault
- *
- * Permission to use, copy, modify, distribute, and sell this
- * software and its documentation for any purpose is hereby granted
- * without fee, provided that the above copyright notice appear in
- * all copies and that both that copyright notice and this permission
- * notice appear in supporting documentation, and that the name of
- * the copyright holders not be used in advertising or publicity
- * pertaining to distribution of the software without specific,
- * written prior permission.  The copyright holders make no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
- * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
- * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
- * THIS SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <stdint.h>
-#include "wayland-util.h"
-
-#ifndef __has_attribute
-# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
-#endif
-
-#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
-#define WL_PRIVATE __attribute__ ((visibility("hidden")))
-#else
-#define WL_PRIVATE
-#endif
-
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface wl_surface_interface;
-extern const struct wl_interface xdg_popup_interface;
-extern const struct wl_interface zwlr_layer_surface_v1_interface;
-
-static const struct wl_interface *wlr_layer_shell_unstable_v1_types[] = {
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	&zwlr_layer_surface_v1_interface,
-	&wl_surface_interface,
-	&wl_output_interface,
-	NULL,
-	NULL,
-	&xdg_popup_interface,
-};
-
-static const struct wl_message zwlr_layer_shell_v1_requests[] = {
-	{ "get_layer_surface", "no?ous", wlr_layer_shell_unstable_v1_types + 4 },
-	{ "destroy", "3", wlr_layer_shell_unstable_v1_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface zwlr_layer_shell_v1_interface = {
-	"zwlr_layer_shell_v1", 4,
-	2, zwlr_layer_shell_v1_requests,
-	0, NULL,
-};
-
-static const struct wl_message zwlr_layer_surface_v1_requests[] = {
-	{ "set_size", "uu", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "set_anchor", "u", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "set_exclusive_zone", "i", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "set_margin", "iiii", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "set_keyboard_interactivity", "u", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "get_popup", "o", wlr_layer_shell_unstable_v1_types + 9 },
-	{ "ack_configure", "u", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "destroy", "", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "set_layer", "2u", wlr_layer_shell_unstable_v1_types + 0 },
-};
-
-static const struct wl_message zwlr_layer_surface_v1_events[] = {
-	{ "configure", "uuu", wlr_layer_shell_unstable_v1_types + 0 },
-	{ "closed", "", wlr_layer_shell_unstable_v1_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface zwlr_layer_surface_v1_interface = {
-	"zwlr_layer_surface_v1", 4,
-	9, zwlr_layer_surface_v1_requests,
-	2, zwlr_layer_surface_v1_events,
-};
-
diff --git a/src/xdg-output-unstable-v1-client-protocol.h b/src/xdg-output-unstable-v1-client-protocol.h
deleted file mode 100644
index 0a8466a..0000000
--- a/src/xdg-output-unstable-v1-client-protocol.h
+++ /dev/null
@@ -1,411 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-#ifndef XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H
-#define XDG_OUTPUT_UNSTABLE_V1_CLIENT_PROTOCOL_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "wayland-client.h"
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-/**
- * @page page_xdg_output_unstable_v1 The xdg_output_unstable_v1 protocol
- * Protocol to describe output regions
- *
- * @section page_desc_xdg_output_unstable_v1 Description
- *
- * This protocol aims at describing outputs in a way which is more in line
- * with the concept of an output on desktop oriented systems.
- *
- * Some information are more specific to the concept of an output for
- * a desktop oriented system and may not make sense in other applications,
- * such as IVI systems for example.
- *
- * Typically, the global compositor space on a desktop system is made of
- * a contiguous or overlapping set of rectangular regions.
- *
- * Some of the information provided in this protocol might be identical
- * to their counterparts already available from wl_output, in which case
- * the information provided by this protocol should be preferred to their
- * equivalent in wl_output. The goal is to move the desktop specific
- * concepts (such as output location within the global compositor space,
- * the connector name and types, etc.) out of the core wl_output protocol.
- *
- * Warning! The protocol described in this file is experimental and
- * backward incompatible changes may be made. Backward compatible
- * changes may be added together with the corresponding interface
- * version bump.
- * Backward incompatible changes are done by bumping the version
- * number in the protocol and interface names and resetting the
- * interface version. Once the protocol is to be declared stable,
- * the 'z' prefix and the version number in the protocol and
- * interface names are removed and the interface version number is
- * reset.
- *
- * @section page_ifaces_xdg_output_unstable_v1 Interfaces
- * - @subpage page_iface_zxdg_output_manager_v1 - manage xdg_output objects
- * - @subpage page_iface_zxdg_output_v1 - compositor logical output region
- * @section page_copyright_xdg_output_unstable_v1 Copyright
- * <pre>
- *
- * Copyright  2017 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- * </pre>
- */
-struct wl_output;
-struct zxdg_output_manager_v1;
-struct zxdg_output_v1;
-
-#ifndef ZXDG_OUTPUT_MANAGER_V1_INTERFACE
-#define ZXDG_OUTPUT_MANAGER_V1_INTERFACE
-/**
- * @page page_iface_zxdg_output_manager_v1 zxdg_output_manager_v1
- * @section page_iface_zxdg_output_manager_v1_desc Description
- *
- * A global factory interface for xdg_output objects.
- * @section page_iface_zxdg_output_manager_v1_api API
- * See @ref iface_zxdg_output_manager_v1.
- */
-/**
- * @defgroup iface_zxdg_output_manager_v1 The zxdg_output_manager_v1 interface
- *
- * A global factory interface for xdg_output objects.
- */
-extern const struct wl_interface zxdg_output_manager_v1_interface;
-#endif
-#ifndef ZXDG_OUTPUT_V1_INTERFACE
-#define ZXDG_OUTPUT_V1_INTERFACE
-/**
- * @page page_iface_zxdg_output_v1 zxdg_output_v1
- * @section page_iface_zxdg_output_v1_desc Description
- *
- * An xdg_output describes part of the compositor geometry.
- *
- * This typically corresponds to a monitor that displays part of the
- * compositor space.
- *
- * For objects version 3 onwards, after all xdg_output properties have been
- * sent (when the object is created and when properties are updated), a
- * wl_output.done event is sent. This allows changes to the output
- * properties to be seen as atomic, even if they happen via multiple events.
- * @section page_iface_zxdg_output_v1_api API
- * See @ref iface_zxdg_output_v1.
- */
-/**
- * @defgroup iface_zxdg_output_v1 The zxdg_output_v1 interface
- *
- * An xdg_output describes part of the compositor geometry.
- *
- * This typically corresponds to a monitor that displays part of the
- * compositor space.
- *
- * For objects version 3 onwards, after all xdg_output properties have been
- * sent (when the object is created and when properties are updated), a
- * wl_output.done event is sent. This allows changes to the output
- * properties to be seen as atomic, even if they happen via multiple events.
- */
-extern const struct wl_interface zxdg_output_v1_interface;
-#endif
-
-#define ZXDG_OUTPUT_MANAGER_V1_DESTROY 0
-#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT 1
-
-
-/**
- * @ingroup iface_zxdg_output_manager_v1
- */
-#define ZXDG_OUTPUT_MANAGER_V1_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_zxdg_output_manager_v1
- */
-#define ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT_SINCE_VERSION 1
-
-/** @ingroup iface_zxdg_output_manager_v1 */
-static inline void
-zxdg_output_manager_v1_set_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_manager_v1, user_data);
-}
-
-/** @ingroup iface_zxdg_output_manager_v1 */
-static inline void *
-zxdg_output_manager_v1_get_user_data(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_manager_v1);
-}
-
-static inline uint32_t
-zxdg_output_manager_v1_get_version(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1);
-}
-
-/**
- * @ingroup iface_zxdg_output_manager_v1
- *
- * Using this request a client can tell the server that it is not
- * going to use the xdg_output_manager object anymore.
- *
- * Any objects already created through this instance are not affected.
- */
-static inline void
-zxdg_output_manager_v1_destroy(struct zxdg_output_manager_v1 *zxdg_output_manager_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_manager_v1,
-			 ZXDG_OUTPUT_MANAGER_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_zxdg_output_manager_v1
- *
- * This creates a new xdg_output object for the given wl_output.
- */
-static inline struct zxdg_output_v1 *
-zxdg_output_manager_v1_get_xdg_output(struct zxdg_output_manager_v1 *zxdg_output_manager_v1, struct wl_output *output)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_manager_v1,
-			 ZXDG_OUTPUT_MANAGER_V1_GET_XDG_OUTPUT, &zxdg_output_v1_interface, wl_proxy_get_version((struct wl_proxy *) zxdg_output_manager_v1), 0, NULL, output);
-
-	return (struct zxdg_output_v1 *) id;
-}
-
-/**
- * @ingroup iface_zxdg_output_v1
- * @struct zxdg_output_v1_listener
- */
-struct zxdg_output_v1_listener {
-	/**
-	 * position of the output within the global compositor space
-	 *
-	 * The position event describes the location of the wl_output
-	 * within the global compositor space.
-	 *
-	 * The logical_position event is sent after creating an xdg_output
-	 * (see xdg_output_manager.get_xdg_output) and whenever the
-	 * location of the output changes within the global compositor
-	 * space.
-	 * @param x x position within the global compositor space
-	 * @param y y position within the global compositor space
-	 */
-	void (*logical_position)(void *data,
-				 struct zxdg_output_v1 *zxdg_output_v1,
-				 int32_t x,
-				 int32_t y);
-	/**
-	 * size of the output in the global compositor space
-	 *
-	 * The logical_size event describes the size of the output in the
-	 * global compositor space.
-	 *
-	 * For example, a surface without any buffer scale, transformation
-	 * nor rotation set, with the size matching the logical_size will
-	 * have the same size as the corresponding output when displayed.
-	 *
-	 * Most regular Wayland clients should not pay attention to the
-	 * logical size and would rather rely on xdg_shell interfaces.
-	 *
-	 * Some clients such as Xwayland, however, need this to configure
-	 * their surfaces in the global compositor space as the compositor
-	 * may apply a different scale from what is advertised by the
-	 * output scaling property (to achieve fractional scaling, for
-	 * example).
-	 *
-	 * For example, for a wl_output mode 38402160 and a scale factor
-	 * 2:
-	 *
-	 * - A compositor not scaling the surface buffers will advertise a
-	 * logical size of 38402160,
-	 *
-	 * - A compositor automatically scaling the surface buffers will
-	 * advertise a logical size of 19201080,
-	 *
-	 * - A compositor using a fractional scale of 1.5 will advertise a
-	 * logical size of 25601440.
-	 *
-	 * For example, for a wl_output mode 19201080 and a 90 degree
-	 * rotation, the compositor will advertise a logical size of
-	 * 1080x1920.
-	 *
-	 * The logical_size event is sent after creating an xdg_output (see
-	 * xdg_output_manager.get_xdg_output) and whenever the logical size
-	 * of the output changes, either as a result of a change in the
-	 * applied scale or because of a change in the corresponding output
-	 * mode(see wl_output.mode) or transform (see wl_output.transform).
-	 * @param width width in global compositor space
-	 * @param height height in global compositor space
-	 */
-	void (*logical_size)(void *data,
-			     struct zxdg_output_v1 *zxdg_output_v1,
-			     int32_t width,
-			     int32_t height);
-	/**
-	 * all information about the output have been sent
-	 *
-	 * This event is sent after all other properties of an xdg_output
-	 * have been sent.
-	 *
-	 * This allows changes to the xdg_output properties to be seen as
-	 * atomic, even if they happen via multiple events.
-	 *
-	 * For objects version 3 onwards, this event is deprecated.
-	 * Compositors are not required to send it anymore and must send
-	 * wl_output.done instead.
-	 */
-	void (*done)(void *data,
-		     struct zxdg_output_v1 *zxdg_output_v1);
-	/**
-	 * name of this output
-	 *
-	 * Many compositors will assign names to their outputs, show them
-	 * to the user, allow them to be configured by name, etc. The
-	 * client may wish to know this name as well to offer the user
-	 * similar behaviors.
-	 *
-	 * The naming convention is compositor defined, but limited to
-	 * alphanumeric characters and dashes (-). Each name is unique
-	 * among all wl_output globals, but if a wl_output global is
-	 * destroyed the same name may be reused later. The names will also
-	 * remain consistent across sessions with the same hardware and
-	 * software configuration.
-	 *
-	 * Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.
-	 * However, do not assume that the name is a reflection of an
-	 * underlying DRM connector, X11 connection, etc.
-	 *
-	 * The name event is sent after creating an xdg_output (see
-	 * xdg_output_manager.get_xdg_output). This event is only sent once
-	 * per xdg_output, and the name does not change over the lifetime
-	 * of the wl_output global.
-	 * @param name output name
-	 * @since 2
-	 */
-	void (*name)(void *data,
-		     struct zxdg_output_v1 *zxdg_output_v1,
-		     const char *name);
-	/**
-	 * human-readable description of this output
-	 *
-	 * Many compositors can produce human-readable descriptions of
-	 * their outputs. The client may wish to know this description as
-	 * well, to communicate the user for various purposes.
-	 *
-	 * The description is a UTF-8 string with no convention defined for
-	 * its contents. Examples might include 'Foocorp 11" Display' or
-	 * 'Virtual X11 output via :1'.
-	 *
-	 * The description event is sent after creating an xdg_output (see
-	 * xdg_output_manager.get_xdg_output) and whenever the description
-	 * changes. The description is optional, and may not be sent at
-	 * all.
-	 *
-	 * For objects of version 2 and lower, this event is only sent once
-	 * per xdg_output, and the description does not change over the
-	 * lifetime of the wl_output global.
-	 * @param description output description
-	 * @since 2
-	 */
-	void (*description)(void *data,
-			    struct zxdg_output_v1 *zxdg_output_v1,
-			    const char *description);
-};
-
-/**
- * @ingroup iface_zxdg_output_v1
- */
-static inline int
-zxdg_output_v1_add_listener(struct zxdg_output_v1 *zxdg_output_v1,
-			    const struct zxdg_output_v1_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) zxdg_output_v1,
-				     (void (**)(void)) listener, data);
-}
-
-#define ZXDG_OUTPUT_V1_DESTROY 0
-
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_LOGICAL_POSITION_SINCE_VERSION 1
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_LOGICAL_SIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_DONE_SINCE_VERSION 1
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_NAME_SINCE_VERSION 2
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_DESCRIPTION_SINCE_VERSION 2
-
-/**
- * @ingroup iface_zxdg_output_v1
- */
-#define ZXDG_OUTPUT_V1_DESTROY_SINCE_VERSION 1
-
-/** @ingroup iface_zxdg_output_v1 */
-static inline void
-zxdg_output_v1_set_user_data(struct zxdg_output_v1 *zxdg_output_v1, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) zxdg_output_v1, user_data);
-}
-
-/** @ingroup iface_zxdg_output_v1 */
-static inline void *
-zxdg_output_v1_get_user_data(struct zxdg_output_v1 *zxdg_output_v1)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) zxdg_output_v1);
-}
-
-static inline uint32_t
-zxdg_output_v1_get_version(struct zxdg_output_v1 *zxdg_output_v1)
-{
-	return wl_proxy_get_version((struct wl_proxy *) zxdg_output_v1);
-}
-
-/**
- * @ingroup iface_zxdg_output_v1
- *
- * Using this request a client can tell the server that it is not
- * going to use the xdg_output object anymore.
- */
-static inline void
-zxdg_output_v1_destroy(struct zxdg_output_v1 *zxdg_output_v1)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) zxdg_output_v1,
-			 ZXDG_OUTPUT_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) zxdg_output_v1), WL_MARSHAL_FLAG_DESTROY);
-}
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/xdg-output-unstable-v1-protocol.c b/src/xdg-output-unstable-v1-protocol.c
deleted file mode 100644
index 07dda30..0000000
--- a/src/xdg-output-unstable-v1-protocol.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-/*
- * Copyright  2017 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <stdint.h>
-#include "wayland-util.h"
-
-#ifndef __has_attribute
-# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
-#endif
-
-#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
-#define WL_PRIVATE __attribute__ ((visibility("hidden")))
-#else
-#define WL_PRIVATE
-#endif
-
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface zxdg_output_v1_interface;
-
-static const struct wl_interface *xdg_output_unstable_v1_types[] = {
-	NULL,
-	NULL,
-	&zxdg_output_v1_interface,
-	&wl_output_interface,
-};
-
-static const struct wl_message zxdg_output_manager_v1_requests[] = {
-	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
-	{ "get_xdg_output", "no", xdg_output_unstable_v1_types + 2 },
-};
-
-WL_PRIVATE const struct wl_interface zxdg_output_manager_v1_interface = {
-	"zxdg_output_manager_v1", 3,
-	2, zxdg_output_manager_v1_requests,
-	0, NULL,
-};
-
-static const struct wl_message zxdg_output_v1_requests[] = {
-	{ "destroy", "", xdg_output_unstable_v1_types + 0 },
-};
-
-static const struct wl_message zxdg_output_v1_events[] = {
-	{ "logical_position", "ii", xdg_output_unstable_v1_types + 0 },
-	{ "logical_size", "ii", xdg_output_unstable_v1_types + 0 },
-	{ "done", "", xdg_output_unstable_v1_types + 0 },
-	{ "name", "2s", xdg_output_unstable_v1_types + 0 },
-	{ "description", "2s", xdg_output_unstable_v1_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface zxdg_output_v1_interface = {
-	"zxdg_output_v1", 3,
-	1, zxdg_output_v1_requests,
-	5, zxdg_output_v1_events,
-};
-
diff --git a/src/xdg-shell-client-protocol.h b/src/xdg-shell-client-protocol.h
deleted file mode 100644
index aa14e2e..0000000
--- a/src/xdg-shell-client-protocol.h
+++ /dev/null
@@ -1,2280 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-#ifndef XDG_SHELL_CLIENT_PROTOCOL_H
-#define XDG_SHELL_CLIENT_PROTOCOL_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "wayland-client.h"
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-/**
- * @page page_xdg_shell The xdg_shell protocol
- * @section page_ifaces_xdg_shell Interfaces
- * - @subpage page_iface_xdg_wm_base - create desktop-style surfaces
- * - @subpage page_iface_xdg_positioner - child surface positioner
- * - @subpage page_iface_xdg_surface - desktop user interface surface base interface
- * - @subpage page_iface_xdg_toplevel - toplevel surface
- * - @subpage page_iface_xdg_popup - short-lived, popup surfaces for menus
- * @section page_copyright_xdg_shell Copyright
- * <pre>
- *
- * Copyright  2008-2013 Kristian Hgsberg
- * Copyright  2013      Rafael Antognolli
- * Copyright  2013      Jasper St. Pierre
- * Copyright  2010-2013 Intel Corporation
- * Copyright  2015-2017 Samsung Electronics Co., Ltd
- * Copyright  2015-2017 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- * </pre>
- */
-struct wl_output;
-struct wl_seat;
-struct wl_surface;
-struct xdg_popup;
-struct xdg_positioner;
-struct xdg_surface;
-struct xdg_toplevel;
-struct xdg_wm_base;
-
-#ifndef XDG_WM_BASE_INTERFACE
-#define XDG_WM_BASE_INTERFACE
-/**
- * @page page_iface_xdg_wm_base xdg_wm_base
- * @section page_iface_xdg_wm_base_desc Description
- *
- * The xdg_wm_base interface is exposed as a global object enabling clients
- * to turn their wl_surfaces into windows in a desktop environment. It
- * defines the basic functionality needed for clients and the compositor to
- * create windows that can be dragged, resized, maximized, etc, as well as
- * creating transient windows such as popup menus.
- * @section page_iface_xdg_wm_base_api API
- * See @ref iface_xdg_wm_base.
- */
-/**
- * @defgroup iface_xdg_wm_base The xdg_wm_base interface
- *
- * The xdg_wm_base interface is exposed as a global object enabling clients
- * to turn their wl_surfaces into windows in a desktop environment. It
- * defines the basic functionality needed for clients and the compositor to
- * create windows that can be dragged, resized, maximized, etc, as well as
- * creating transient windows such as popup menus.
- */
-extern const struct wl_interface xdg_wm_base_interface;
-#endif
-#ifndef XDG_POSITIONER_INTERFACE
-#define XDG_POSITIONER_INTERFACE
-/**
- * @page page_iface_xdg_positioner xdg_positioner
- * @section page_iface_xdg_positioner_desc Description
- *
- * The xdg_positioner provides a collection of rules for the placement of a
- * child surface relative to a parent surface. Rules can be defined to ensure
- * the child surface remains within the visible area's borders, and to
- * specify how the child surface changes its position, such as sliding along
- * an axis, or flipping around a rectangle. These positioner-created rules are
- * constrained by the requirement that a child surface must intersect with or
- * be at least partially adjacent to its parent surface.
- *
- * See the various requests for details about possible rules.
- *
- * At the time of the request, the compositor makes a copy of the rules
- * specified by the xdg_positioner. Thus, after the request is complete the
- * xdg_positioner object can be destroyed or reused; further changes to the
- * object will have no effect on previous usages.
- *
- * For an xdg_positioner object to be considered complete, it must have a
- * non-zero size set by set_size, and a non-zero anchor rectangle set by
- * set_anchor_rect. Passing an incomplete xdg_positioner object when
- * positioning a surface raises an invalid_positioner error.
- * @section page_iface_xdg_positioner_api API
- * See @ref iface_xdg_positioner.
- */
-/**
- * @defgroup iface_xdg_positioner The xdg_positioner interface
- *
- * The xdg_positioner provides a collection of rules for the placement of a
- * child surface relative to a parent surface. Rules can be defined to ensure
- * the child surface remains within the visible area's borders, and to
- * specify how the child surface changes its position, such as sliding along
- * an axis, or flipping around a rectangle. These positioner-created rules are
- * constrained by the requirement that a child surface must intersect with or
- * be at least partially adjacent to its parent surface.
- *
- * See the various requests for details about possible rules.
- *
- * At the time of the request, the compositor makes a copy of the rules
- * specified by the xdg_positioner. Thus, after the request is complete the
- * xdg_positioner object can be destroyed or reused; further changes to the
- * object will have no effect on previous usages.
- *
- * For an xdg_positioner object to be considered complete, it must have a
- * non-zero size set by set_size, and a non-zero anchor rectangle set by
- * set_anchor_rect. Passing an incomplete xdg_positioner object when
- * positioning a surface raises an invalid_positioner error.
- */
-extern const struct wl_interface xdg_positioner_interface;
-#endif
-#ifndef XDG_SURFACE_INTERFACE
-#define XDG_SURFACE_INTERFACE
-/**
- * @page page_iface_xdg_surface xdg_surface
- * @section page_iface_xdg_surface_desc Description
- *
- * An interface that may be implemented by a wl_surface, for
- * implementations that provide a desktop-style user interface.
- *
- * It provides a base set of functionality required to construct user
- * interface elements requiring management by the compositor, such as
- * toplevel windows, menus, etc. The types of functionality are split into
- * xdg_surface roles.
- *
- * Creating an xdg_surface does not set the role for a wl_surface. In order
- * to map an xdg_surface, the client must create a role-specific object
- * using, e.g., get_toplevel, get_popup. The wl_surface for any given
- * xdg_surface can have at most one role, and may not be assigned any role
- * not based on xdg_surface.
- *
- * A role must be assigned before any other requests are made to the
- * xdg_surface object.
- *
- * The client must call wl_surface.commit on the corresponding wl_surface
- * for the xdg_surface state to take effect.
- *
- * Creating an xdg_surface from a wl_surface which has a buffer attached or
- * committed is a client error, and any attempts by a client to attach or
- * manipulate a buffer prior to the first xdg_surface.configure call must
- * also be treated as errors.
- *
- * After creating a role-specific object and setting it up, the client must
- * perform an initial commit without any buffer attached. The compositor
- * will reply with an xdg_surface.configure event. The client must
- * acknowledge it and is then allowed to attach a buffer to map the surface.
- *
- * Mapping an xdg_surface-based role surface is defined as making it
- * possible for the surface to be shown by the compositor. Note that
- * a mapped surface is not guaranteed to be visible once it is mapped.
- *
- * For an xdg_surface to be mapped by the compositor, the following
- * conditions must be met:
- * (1) the client has assigned an xdg_surface-based role to the surface
- * (2) the client has set and committed the xdg_surface state and the
- * role-dependent state to the surface
- * (3) the client has committed a buffer to the surface
- *
- * A newly-unmapped surface is considered to have met condition (1) out
- * of the 3 required conditions for mapping a surface if its role surface
- * has not been destroyed, i.e. the client must perform the initial commit
- * again before attaching a buffer.
- * @section page_iface_xdg_surface_api API
- * See @ref iface_xdg_surface.
- */
-/**
- * @defgroup iface_xdg_surface The xdg_surface interface
- *
- * An interface that may be implemented by a wl_surface, for
- * implementations that provide a desktop-style user interface.
- *
- * It provides a base set of functionality required to construct user
- * interface elements requiring management by the compositor, such as
- * toplevel windows, menus, etc. The types of functionality are split into
- * xdg_surface roles.
- *
- * Creating an xdg_surface does not set the role for a wl_surface. In order
- * to map an xdg_surface, the client must create a role-specific object
- * using, e.g., get_toplevel, get_popup. The wl_surface for any given
- * xdg_surface can have at most one role, and may not be assigned any role
- * not based on xdg_surface.
- *
- * A role must be assigned before any other requests are made to the
- * xdg_surface object.
- *
- * The client must call wl_surface.commit on the corresponding wl_surface
- * for the xdg_surface state to take effect.
- *
- * Creating an xdg_surface from a wl_surface which has a buffer attached or
- * committed is a client error, and any attempts by a client to attach or
- * manipulate a buffer prior to the first xdg_surface.configure call must
- * also be treated as errors.
- *
- * After creating a role-specific object and setting it up, the client must
- * perform an initial commit without any buffer attached. The compositor
- * will reply with an xdg_surface.configure event. The client must
- * acknowledge it and is then allowed to attach a buffer to map the surface.
- *
- * Mapping an xdg_surface-based role surface is defined as making it
- * possible for the surface to be shown by the compositor. Note that
- * a mapped surface is not guaranteed to be visible once it is mapped.
- *
- * For an xdg_surface to be mapped by the compositor, the following
- * conditions must be met:
- * (1) the client has assigned an xdg_surface-based role to the surface
- * (2) the client has set and committed the xdg_surface state and the
- * role-dependent state to the surface
- * (3) the client has committed a buffer to the surface
- *
- * A newly-unmapped surface is considered to have met condition (1) out
- * of the 3 required conditions for mapping a surface if its role surface
- * has not been destroyed, i.e. the client must perform the initial commit
- * again before attaching a buffer.
- */
-extern const struct wl_interface xdg_surface_interface;
-#endif
-#ifndef XDG_TOPLEVEL_INTERFACE
-#define XDG_TOPLEVEL_INTERFACE
-/**
- * @page page_iface_xdg_toplevel xdg_toplevel
- * @section page_iface_xdg_toplevel_desc Description
- *
- * This interface defines an xdg_surface role which allows a surface to,
- * among other things, set window-like properties such as maximize,
- * fullscreen, and minimize, set application-specific metadata like title and
- * id, and well as trigger user interactive operations such as interactive
- * resize and move.
- *
- * Unmapping an xdg_toplevel means that the surface cannot be shown
- * by the compositor until it is explicitly mapped again.
- * All active operations (e.g., move, resize) are canceled and all
- * attributes (e.g. title, state, stacking, ...) are discarded for
- * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
- * the state it had right after xdg_surface.get_toplevel. The client
- * can re-map the toplevel by perfoming a commit without any buffer
- * attached, waiting for a configure event and handling it as usual (see
- * xdg_surface description).
- *
- * Attaching a null buffer to a toplevel unmaps the surface.
- * @section page_iface_xdg_toplevel_api API
- * See @ref iface_xdg_toplevel.
- */
-/**
- * @defgroup iface_xdg_toplevel The xdg_toplevel interface
- *
- * This interface defines an xdg_surface role which allows a surface to,
- * among other things, set window-like properties such as maximize,
- * fullscreen, and minimize, set application-specific metadata like title and
- * id, and well as trigger user interactive operations such as interactive
- * resize and move.
- *
- * Unmapping an xdg_toplevel means that the surface cannot be shown
- * by the compositor until it is explicitly mapped again.
- * All active operations (e.g., move, resize) are canceled and all
- * attributes (e.g. title, state, stacking, ...) are discarded for
- * an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
- * the state it had right after xdg_surface.get_toplevel. The client
- * can re-map the toplevel by perfoming a commit without any buffer
- * attached, waiting for a configure event and handling it as usual (see
- * xdg_surface description).
- *
- * Attaching a null buffer to a toplevel unmaps the surface.
- */
-extern const struct wl_interface xdg_toplevel_interface;
-#endif
-#ifndef XDG_POPUP_INTERFACE
-#define XDG_POPUP_INTERFACE
-/**
- * @page page_iface_xdg_popup xdg_popup
- * @section page_iface_xdg_popup_desc Description
- *
- * A popup surface is a short-lived, temporary surface. It can be used to
- * implement for example menus, popovers, tooltips and other similar user
- * interface concepts.
- *
- * A popup can be made to take an explicit grab. See xdg_popup.grab for
- * details.
- *
- * When the popup is dismissed, a popup_done event will be sent out, and at
- * the same time the surface will be unmapped. See the xdg_popup.popup_done
- * event for details.
- *
- * Explicitly destroying the xdg_popup object will also dismiss the popup and
- * unmap the surface. Clients that want to dismiss the popup when another
- * surface of their own is clicked should dismiss the popup using the destroy
- * request.
- *
- * A newly created xdg_popup will be stacked on top of all previously created
- * xdg_popup surfaces associated with the same xdg_toplevel.
- *
- * The parent of an xdg_popup must be mapped (see the xdg_surface
- * description) before the xdg_popup itself.
- *
- * The client must call wl_surface.commit on the corresponding wl_surface
- * for the xdg_popup state to take effect.
- * @section page_iface_xdg_popup_api API
- * See @ref iface_xdg_popup.
- */
-/**
- * @defgroup iface_xdg_popup The xdg_popup interface
- *
- * A popup surface is a short-lived, temporary surface. It can be used to
- * implement for example menus, popovers, tooltips and other similar user
- * interface concepts.
- *
- * A popup can be made to take an explicit grab. See xdg_popup.grab for
- * details.
- *
- * When the popup is dismissed, a popup_done event will be sent out, and at
- * the same time the surface will be unmapped. See the xdg_popup.popup_done
- * event for details.
- *
- * Explicitly destroying the xdg_popup object will also dismiss the popup and
- * unmap the surface. Clients that want to dismiss the popup when another
- * surface of their own is clicked should dismiss the popup using the destroy
- * request.
- *
- * A newly created xdg_popup will be stacked on top of all previously created
- * xdg_popup surfaces associated with the same xdg_toplevel.
- *
- * The parent of an xdg_popup must be mapped (see the xdg_surface
- * description) before the xdg_popup itself.
- *
- * The client must call wl_surface.commit on the corresponding wl_surface
- * for the xdg_popup state to take effect.
- */
-extern const struct wl_interface xdg_popup_interface;
-#endif
-
-#ifndef XDG_WM_BASE_ERROR_ENUM
-#define XDG_WM_BASE_ERROR_ENUM
-enum xdg_wm_base_error {
-	/**
-	 * given wl_surface has another role
-	 */
-	XDG_WM_BASE_ERROR_ROLE = 0,
-	/**
-	 * xdg_wm_base was destroyed before children
-	 */
-	XDG_WM_BASE_ERROR_DEFUNCT_SURFACES = 1,
-	/**
-	 * the client tried to map or destroy a non-topmost popup
-	 */
-	XDG_WM_BASE_ERROR_NOT_THE_TOPMOST_POPUP = 2,
-	/**
-	 * the client specified an invalid popup parent surface
-	 */
-	XDG_WM_BASE_ERROR_INVALID_POPUP_PARENT = 3,
-	/**
-	 * the client provided an invalid surface state
-	 */
-	XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE = 4,
-	/**
-	 * the client provided an invalid positioner
-	 */
-	XDG_WM_BASE_ERROR_INVALID_POSITIONER = 5,
-	/**
-	 * the client didnt respond to a ping event in time
-	 */
-	XDG_WM_BASE_ERROR_UNRESPONSIVE = 6,
-};
-#endif /* XDG_WM_BASE_ERROR_ENUM */
-
-/**
- * @ingroup iface_xdg_wm_base
- * @struct xdg_wm_base_listener
- */
-struct xdg_wm_base_listener {
-	/**
-	 * check if the client is alive
-	 *
-	 * The ping event asks the client if it's still alive. Pass the
-	 * serial specified in the event back to the compositor by sending
-	 * a "pong" request back with the specified serial. See
-	 * xdg_wm_base.pong.
-	 *
-	 * Compositors can use this to determine if the client is still
-	 * alive. It's unspecified what will happen if the client doesn't
-	 * respond to the ping request, or in what timeframe. Clients
-	 * should try to respond in a reasonable amount of time. The
-	 * unresponsive error is provided for compositors that wish
-	 * to disconnect unresponsive clients.
-	 *
-	 * A compositor is free to ping in any way it wants, but a client
-	 * must always respond to any xdg_wm_base object it created.
-	 * @param serial pass this to the pong request
-	 */
-	void (*ping)(void *data,
-		     struct xdg_wm_base *xdg_wm_base,
-		     uint32_t serial);
-};
-
-/**
- * @ingroup iface_xdg_wm_base
- */
-static inline int
-xdg_wm_base_add_listener(struct xdg_wm_base *xdg_wm_base,
-			 const struct xdg_wm_base_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) xdg_wm_base,
-				     (void (**)(void)) listener, data);
-}
-
-#define XDG_WM_BASE_DESTROY 0
-#define XDG_WM_BASE_CREATE_POSITIONER 1
-#define XDG_WM_BASE_GET_XDG_SURFACE 2
-#define XDG_WM_BASE_PONG 3
-
-/**
- * @ingroup iface_xdg_wm_base
- */
-#define XDG_WM_BASE_PING_SINCE_VERSION 1
-
-/**
- * @ingroup iface_xdg_wm_base
- */
-#define XDG_WM_BASE_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_wm_base
- */
-#define XDG_WM_BASE_CREATE_POSITIONER_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_wm_base
- */
-#define XDG_WM_BASE_GET_XDG_SURFACE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_wm_base
- */
-#define XDG_WM_BASE_PONG_SINCE_VERSION 1
-
-/** @ingroup iface_xdg_wm_base */
-static inline void
-xdg_wm_base_set_user_data(struct xdg_wm_base *xdg_wm_base, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) xdg_wm_base, user_data);
-}
-
-/** @ingroup iface_xdg_wm_base */
-static inline void *
-xdg_wm_base_get_user_data(struct xdg_wm_base *xdg_wm_base)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) xdg_wm_base);
-}
-
-static inline uint32_t
-xdg_wm_base_get_version(struct xdg_wm_base *xdg_wm_base)
-{
-	return wl_proxy_get_version((struct wl_proxy *) xdg_wm_base);
-}
-
-/**
- * @ingroup iface_xdg_wm_base
- *
- * Destroy this xdg_wm_base object.
- *
- * Destroying a bound xdg_wm_base object while there are surfaces
- * still alive created by this xdg_wm_base object instance is illegal
- * and will result in a defunct_surfaces error.
- */
-static inline void
-xdg_wm_base_destroy(struct xdg_wm_base *xdg_wm_base)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
-			 XDG_WM_BASE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_xdg_wm_base
- *
- * Create a positioner object. A positioner object is used to position
- * surfaces relative to some parent surface. See the interface description
- * and xdg_surface.get_popup for details.
- */
-static inline struct xdg_positioner *
-xdg_wm_base_create_positioner(struct xdg_wm_base *xdg_wm_base)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
-			 XDG_WM_BASE_CREATE_POSITIONER, &xdg_positioner_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL);
-
-	return (struct xdg_positioner *) id;
-}
-
-/**
- * @ingroup iface_xdg_wm_base
- *
- * This creates an xdg_surface for the given surface. While xdg_surface
- * itself is not a role, the corresponding surface may only be assigned
- * a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
- * illegal to create an xdg_surface for a wl_surface which already has an
- * assigned role and this will result in a role error.
- *
- * This creates an xdg_surface for the given surface. An xdg_surface is
- * used as basis to define a role to a given surface, such as xdg_toplevel
- * or xdg_popup. It also manages functionality shared between xdg_surface
- * based surface roles.
- *
- * See the documentation of xdg_surface for more details about what an
- * xdg_surface is and how it is used.
- */
-static inline struct xdg_surface *
-xdg_wm_base_get_xdg_surface(struct xdg_wm_base *xdg_wm_base, struct wl_surface *surface)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
-			 XDG_WM_BASE_GET_XDG_SURFACE, &xdg_surface_interface, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, NULL, surface);
-
-	return (struct xdg_surface *) id;
-}
-
-/**
- * @ingroup iface_xdg_wm_base
- *
- * A client must respond to a ping event with a pong request or
- * the client may be deemed unresponsive. See xdg_wm_base.ping
- * and xdg_wm_base.error.unresponsive.
- */
-static inline void
-xdg_wm_base_pong(struct xdg_wm_base *xdg_wm_base, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_wm_base,
-			 XDG_WM_BASE_PONG, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_wm_base), 0, serial);
-}
-
-#ifndef XDG_POSITIONER_ERROR_ENUM
-#define XDG_POSITIONER_ERROR_ENUM
-enum xdg_positioner_error {
-	/**
-	 * invalid input provided
-	 */
-	XDG_POSITIONER_ERROR_INVALID_INPUT = 0,
-};
-#endif /* XDG_POSITIONER_ERROR_ENUM */
-
-#ifndef XDG_POSITIONER_ANCHOR_ENUM
-#define XDG_POSITIONER_ANCHOR_ENUM
-enum xdg_positioner_anchor {
-	XDG_POSITIONER_ANCHOR_NONE = 0,
-	XDG_POSITIONER_ANCHOR_TOP = 1,
-	XDG_POSITIONER_ANCHOR_BOTTOM = 2,
-	XDG_POSITIONER_ANCHOR_LEFT = 3,
-	XDG_POSITIONER_ANCHOR_RIGHT = 4,
-	XDG_POSITIONER_ANCHOR_TOP_LEFT = 5,
-	XDG_POSITIONER_ANCHOR_BOTTOM_LEFT = 6,
-	XDG_POSITIONER_ANCHOR_TOP_RIGHT = 7,
-	XDG_POSITIONER_ANCHOR_BOTTOM_RIGHT = 8,
-};
-#endif /* XDG_POSITIONER_ANCHOR_ENUM */
-
-#ifndef XDG_POSITIONER_GRAVITY_ENUM
-#define XDG_POSITIONER_GRAVITY_ENUM
-enum xdg_positioner_gravity {
-	XDG_POSITIONER_GRAVITY_NONE = 0,
-	XDG_POSITIONER_GRAVITY_TOP = 1,
-	XDG_POSITIONER_GRAVITY_BOTTOM = 2,
-	XDG_POSITIONER_GRAVITY_LEFT = 3,
-	XDG_POSITIONER_GRAVITY_RIGHT = 4,
-	XDG_POSITIONER_GRAVITY_TOP_LEFT = 5,
-	XDG_POSITIONER_GRAVITY_BOTTOM_LEFT = 6,
-	XDG_POSITIONER_GRAVITY_TOP_RIGHT = 7,
-	XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT = 8,
-};
-#endif /* XDG_POSITIONER_GRAVITY_ENUM */
-
-#ifndef XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
-#define XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM
-/**
- * @ingroup iface_xdg_positioner
- * constraint adjustments
- *
- * The constraint adjustment value define ways the compositor will adjust
- * the position of the surface, if the unadjusted position would result
- * in the surface being partly constrained.
- *
- * Whether a surface is considered 'constrained' is left to the compositor
- * to determine. For example, the surface may be partly outside the
- * compositor's defined 'work area', thus necessitating the child surface's
- * position be adjusted until it is entirely inside the work area.
- *
- * The adjustments can be combined, according to a defined precedence: 1)
- * Flip, 2) Slide, 3) Resize.
- */
-enum xdg_positioner_constraint_adjustment {
-	/**
-	 * don't move the child surface when constrained
-	 *
-	 * Don't alter the surface position even if it is constrained on
-	 * some axis, for example partially outside the edge of an output.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_NONE = 0,
-	/**
-	 * move along the x axis until unconstrained
-	 *
-	 * Slide the surface along the x axis until it is no longer
-	 * constrained.
-	 *
-	 * First try to slide towards the direction of the gravity on the x
-	 * axis until either the edge in the opposite direction of the
-	 * gravity is unconstrained or the edge in the direction of the
-	 * gravity is constrained.
-	 *
-	 * Then try to slide towards the opposite direction of the gravity
-	 * on the x axis until either the edge in the direction of the
-	 * gravity is unconstrained or the edge in the opposite direction
-	 * of the gravity is constrained.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X = 1,
-	/**
-	 * move along the y axis until unconstrained
-	 *
-	 * Slide the surface along the y axis until it is no longer
-	 * constrained.
-	 *
-	 * First try to slide towards the direction of the gravity on the y
-	 * axis until either the edge in the opposite direction of the
-	 * gravity is unconstrained or the edge in the direction of the
-	 * gravity is constrained.
-	 *
-	 * Then try to slide towards the opposite direction of the gravity
-	 * on the y axis until either the edge in the direction of the
-	 * gravity is unconstrained or the edge in the opposite direction
-	 * of the gravity is constrained.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y = 2,
-	/**
-	 * invert the anchor and gravity on the x axis
-	 *
-	 * Invert the anchor and gravity on the x axis if the surface is
-	 * constrained on the x axis. For example, if the left edge of the
-	 * surface is constrained, the gravity is 'left' and the anchor is
-	 * 'left', change the gravity to 'right' and the anchor to 'right'.
-	 *
-	 * If the adjusted position also ends up being constrained, the
-	 * resulting position of the flip_x adjustment will be the one
-	 * before the adjustment.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_X = 4,
-	/**
-	 * invert the anchor and gravity on the y axis
-	 *
-	 * Invert the anchor and gravity on the y axis if the surface is
-	 * constrained on the y axis. For example, if the bottom edge of
-	 * the surface is constrained, the gravity is 'bottom' and the
-	 * anchor is 'bottom', change the gravity to 'top' and the anchor
-	 * to 'top'.
-	 *
-	 * The adjusted position is calculated given the original anchor
-	 * rectangle and offset, but with the new flipped anchor and
-	 * gravity values.
-	 *
-	 * If the adjusted position also ends up being constrained, the
-	 * resulting position of the flip_y adjustment will be the one
-	 * before the adjustment.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y = 8,
-	/**
-	 * horizontally resize the surface
-	 *
-	 * Resize the surface horizontally so that it is completely
-	 * unconstrained.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_X = 16,
-	/**
-	 * vertically resize the surface
-	 *
-	 * Resize the surface vertically so that it is completely
-	 * unconstrained.
-	 */
-	XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_RESIZE_Y = 32,
-};
-#endif /* XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_ENUM */
-
-#define XDG_POSITIONER_DESTROY 0
-#define XDG_POSITIONER_SET_SIZE 1
-#define XDG_POSITIONER_SET_ANCHOR_RECT 2
-#define XDG_POSITIONER_SET_ANCHOR 3
-#define XDG_POSITIONER_SET_GRAVITY 4
-#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT 5
-#define XDG_POSITIONER_SET_OFFSET 6
-#define XDG_POSITIONER_SET_REACTIVE 7
-#define XDG_POSITIONER_SET_PARENT_SIZE 8
-#define XDG_POSITIONER_SET_PARENT_CONFIGURE 9
-
-
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_SIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_ANCHOR_RECT_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_ANCHOR_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_GRAVITY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_OFFSET_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_REACTIVE_SINCE_VERSION 3
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_PARENT_SIZE_SINCE_VERSION 3
-/**
- * @ingroup iface_xdg_positioner
- */
-#define XDG_POSITIONER_SET_PARENT_CONFIGURE_SINCE_VERSION 3
-
-/** @ingroup iface_xdg_positioner */
-static inline void
-xdg_positioner_set_user_data(struct xdg_positioner *xdg_positioner, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) xdg_positioner, user_data);
-}
-
-/** @ingroup iface_xdg_positioner */
-static inline void *
-xdg_positioner_get_user_data(struct xdg_positioner *xdg_positioner)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) xdg_positioner);
-}
-
-static inline uint32_t
-xdg_positioner_get_version(struct xdg_positioner *xdg_positioner)
-{
-	return wl_proxy_get_version((struct wl_proxy *) xdg_positioner);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Notify the compositor that the xdg_positioner will no longer be used.
- */
-static inline void
-xdg_positioner_destroy(struct xdg_positioner *xdg_positioner)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Set the size of the surface that is to be positioned with the positioner
- * object. The size is in surface-local coordinates and corresponds to the
- * window geometry. See xdg_surface.set_window_geometry.
- *
- * If a zero or negative size is set the invalid_input error is raised.
- */
-static inline void
-xdg_positioner_set_size(struct xdg_positioner *xdg_positioner, int32_t width, int32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, width, height);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Specify the anchor rectangle within the parent surface that the child
- * surface will be placed relative to. The rectangle is relative to the
- * window geometry as defined by xdg_surface.set_window_geometry of the
- * parent surface.
- *
- * When the xdg_positioner object is used to position a child surface, the
- * anchor rectangle may not extend outside the window geometry of the
- * positioned child's parent surface.
- *
- * If a negative size is set the invalid_input error is raised.
- */
-static inline void
-xdg_positioner_set_anchor_rect(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y, int32_t width, int32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_ANCHOR_RECT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y, width, height);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Defines the anchor point for the anchor rectangle. The specified anchor
- * is used derive an anchor point that the child surface will be
- * positioned relative to. If a corner anchor is set (e.g. 'top_left' or
- * 'bottom_right'), the anchor point will be at the specified corner;
- * otherwise, the derived anchor point will be centered on the specified
- * edge, or in the center of the anchor rectangle if no edge is specified.
- */
-static inline void
-xdg_positioner_set_anchor(struct xdg_positioner *xdg_positioner, uint32_t anchor)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_ANCHOR, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, anchor);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Defines in what direction a surface should be positioned, relative to
- * the anchor point of the parent surface. If a corner gravity is
- * specified (e.g. 'bottom_right' or 'top_left'), then the child surface
- * will be placed towards the specified gravity; otherwise, the child
- * surface will be centered over the anchor point on any axis that had no
- * gravity specified. If the gravity is not in the gravity enum, an
- * invalid_input error is raised.
- */
-static inline void
-xdg_positioner_set_gravity(struct xdg_positioner *xdg_positioner, uint32_t gravity)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_GRAVITY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, gravity);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Specify how the window should be positioned if the originally intended
- * position caused the surface to be constrained, meaning at least
- * partially outside positioning boundaries set by the compositor. The
- * adjustment is set by constructing a bitmask describing the adjustment to
- * be made when the surface is constrained on that axis.
- *
- * If no bit for one axis is set, the compositor will assume that the child
- * surface should not change its position on that axis when constrained.
- *
- * If more than one bit for one axis is set, the order of how adjustments
- * are applied is specified in the corresponding adjustment descriptions.
- *
- * The default adjustment is none.
- */
-static inline void
-xdg_positioner_set_constraint_adjustment(struct xdg_positioner *xdg_positioner, uint32_t constraint_adjustment)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_CONSTRAINT_ADJUSTMENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, constraint_adjustment);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Specify the surface position offset relative to the position of the
- * anchor on the anchor rectangle and the anchor on the surface. For
- * example if the anchor of the anchor rectangle is at (x, y), the surface
- * has the gravity bottom|right, and the offset is (ox, oy), the calculated
- * surface position will be (x + ox, y + oy). The offset position of the
- * surface is the one used for constraint testing. See
- * set_constraint_adjustment.
- *
- * An example use case is placing a popup menu on top of a user interface
- * element, while aligning the user interface element of the parent surface
- * with some user interface element placed somewhere in the popup surface.
- */
-static inline void
-xdg_positioner_set_offset(struct xdg_positioner *xdg_positioner, int32_t x, int32_t y)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_OFFSET, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, x, y);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * When set reactive, the surface is reconstrained if the conditions used
- * for constraining changed, e.g. the parent window moved.
- *
- * If the conditions changed and the popup was reconstrained, an
- * xdg_popup.configure event is sent with updated geometry, followed by an
- * xdg_surface.configure event.
- */
-static inline void
-xdg_positioner_set_reactive(struct xdg_positioner *xdg_positioner)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_REACTIVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Set the parent window geometry the compositor should use when
- * positioning the popup. The compositor may use this information to
- * determine the future state the popup should be constrained using. If
- * this doesn't match the dimension of the parent the popup is eventually
- * positioned against, the behavior is undefined.
- *
- * The arguments are given in the surface-local coordinate space.
- */
-static inline void
-xdg_positioner_set_parent_size(struct xdg_positioner *xdg_positioner, int32_t parent_width, int32_t parent_height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_PARENT_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, parent_width, parent_height);
-}
-
-/**
- * @ingroup iface_xdg_positioner
- *
- * Set the serial of an xdg_surface.configure event this positioner will be
- * used in response to. The compositor may use this information together
- * with set_parent_size to determine what future state the popup should be
- * constrained using.
- */
-static inline void
-xdg_positioner_set_parent_configure(struct xdg_positioner *xdg_positioner, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_positioner,
-			 XDG_POSITIONER_SET_PARENT_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_positioner), 0, serial);
-}
-
-#ifndef XDG_SURFACE_ERROR_ENUM
-#define XDG_SURFACE_ERROR_ENUM
-enum xdg_surface_error {
-	/**
-	 * Surface was not fully constructed
-	 */
-	XDG_SURFACE_ERROR_NOT_CONSTRUCTED = 1,
-	/**
-	 * Surface was already constructed
-	 */
-	XDG_SURFACE_ERROR_ALREADY_CONSTRUCTED = 2,
-	/**
-	 * Attaching a buffer to an unconfigured surface
-	 */
-	XDG_SURFACE_ERROR_UNCONFIGURED_BUFFER = 3,
-	/**
-	 * Invalid serial number when acking a configure event
-	 */
-	XDG_SURFACE_ERROR_INVALID_SERIAL = 4,
-	/**
-	 * Width or height was zero or negative
-	 */
-	XDG_SURFACE_ERROR_INVALID_SIZE = 5,
-	/**
-	 * Surface was destroyed before its role object
-	 */
-	XDG_SURFACE_ERROR_DEFUNCT_ROLE_OBJECT = 6,
-};
-#endif /* XDG_SURFACE_ERROR_ENUM */
-
-/**
- * @ingroup iface_xdg_surface
- * @struct xdg_surface_listener
- */
-struct xdg_surface_listener {
-	/**
-	 * suggest a surface change
-	 *
-	 * The configure event marks the end of a configure sequence. A
-	 * configure sequence is a set of one or more events configuring
-	 * the state of the xdg_surface, including the final
-	 * xdg_surface.configure event.
-	 *
-	 * Where applicable, xdg_surface surface roles will during a
-	 * configure sequence extend this event as a latched state sent as
-	 * events before the xdg_surface.configure event. Such events
-	 * should be considered to make up a set of atomically applied
-	 * configuration states, where the xdg_surface.configure commits
-	 * the accumulated state.
-	 *
-	 * Clients should arrange their surface for the new states, and
-	 * then send an ack_configure request with the serial sent in this
-	 * configure event at some point before committing the new surface.
-	 *
-	 * If the client receives multiple configure events before it can
-	 * respond to one, it is free to discard all but the last event it
-	 * received.
-	 * @param serial serial of the configure event
-	 */
-	void (*configure)(void *data,
-			  struct xdg_surface *xdg_surface,
-			  uint32_t serial);
-};
-
-/**
- * @ingroup iface_xdg_surface
- */
-static inline int
-xdg_surface_add_listener(struct xdg_surface *xdg_surface,
-			 const struct xdg_surface_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) xdg_surface,
-				     (void (**)(void)) listener, data);
-}
-
-#define XDG_SURFACE_DESTROY 0
-#define XDG_SURFACE_GET_TOPLEVEL 1
-#define XDG_SURFACE_GET_POPUP 2
-#define XDG_SURFACE_SET_WINDOW_GEOMETRY 3
-#define XDG_SURFACE_ACK_CONFIGURE 4
-
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_CONFIGURE_SINCE_VERSION 1
-
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_GET_TOPLEVEL_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_GET_POPUP_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_SET_WINDOW_GEOMETRY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_surface
- */
-#define XDG_SURFACE_ACK_CONFIGURE_SINCE_VERSION 1
-
-/** @ingroup iface_xdg_surface */
-static inline void
-xdg_surface_set_user_data(struct xdg_surface *xdg_surface, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) xdg_surface, user_data);
-}
-
-/** @ingroup iface_xdg_surface */
-static inline void *
-xdg_surface_get_user_data(struct xdg_surface *xdg_surface)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) xdg_surface);
-}
-
-static inline uint32_t
-xdg_surface_get_version(struct xdg_surface *xdg_surface)
-{
-	return wl_proxy_get_version((struct wl_proxy *) xdg_surface);
-}
-
-/**
- * @ingroup iface_xdg_surface
- *
- * Destroy the xdg_surface object. An xdg_surface must only be destroyed
- * after its role object has been destroyed, otherwise
- * a defunct_role_object error is raised.
- */
-static inline void
-xdg_surface_destroy(struct xdg_surface *xdg_surface)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
-			 XDG_SURFACE_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_xdg_surface
- *
- * This creates an xdg_toplevel object for the given xdg_surface and gives
- * the associated wl_surface the xdg_toplevel role.
- *
- * See the documentation of xdg_toplevel for more details about what an
- * xdg_toplevel is and how it is used.
- */
-static inline struct xdg_toplevel *
-xdg_surface_get_toplevel(struct xdg_surface *xdg_surface)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
-			 XDG_SURFACE_GET_TOPLEVEL, &xdg_toplevel_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL);
-
-	return (struct xdg_toplevel *) id;
-}
-
-/**
- * @ingroup iface_xdg_surface
- *
- * This creates an xdg_popup object for the given xdg_surface and gives
- * the associated wl_surface the xdg_popup role.
- *
- * If null is passed as a parent, a parent surface must be specified using
- * some other protocol, before committing the initial state.
- *
- * See the documentation of xdg_popup for more details about what an
- * xdg_popup is and how it is used.
- */
-static inline struct xdg_popup *
-xdg_surface_get_popup(struct xdg_surface *xdg_surface, struct xdg_surface *parent, struct xdg_positioner *positioner)
-{
-	struct wl_proxy *id;
-
-	id = wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
-			 XDG_SURFACE_GET_POPUP, &xdg_popup_interface, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, NULL, parent, positioner);
-
-	return (struct xdg_popup *) id;
-}
-
-/**
- * @ingroup iface_xdg_surface
- *
- * The window geometry of a surface is its "visible bounds" from the
- * user's perspective. Client-side decorations often have invisible
- * portions like drop-shadows which should be ignored for the
- * purposes of aligning, placing and constraining windows.
- *
- * The window geometry is double buffered, and will be applied at the
- * time wl_surface.commit of the corresponding wl_surface is called.
- *
- * When maintaining a position, the compositor should treat the (x, y)
- * coordinate of the window geometry as the top left corner of the window.
- * A client changing the (x, y) window geometry coordinate should in
- * general not alter the position of the window.
- *
- * Once the window geometry of the surface is set, it is not possible to
- * unset it, and it will remain the same until set_window_geometry is
- * called again, even if a new subsurface or buffer is attached.
- *
- * If never set, the value is the full bounds of the surface,
- * including any subsurfaces. This updates dynamically on every
- * commit. This unset is meant for extremely simple clients.
- *
- * The arguments are given in the surface-local coordinate space of
- * the wl_surface associated with this xdg_surface.
- *
- * The width and height must be greater than zero. Setting an invalid size
- * will raise an invalid_size error. When applied, the effective window
- * geometry will be the set window geometry clamped to the bounding
- * rectangle of the combined geometry of the surface of the xdg_surface and
- * the associated subsurfaces.
- */
-static inline void
-xdg_surface_set_window_geometry(struct xdg_surface *xdg_surface, int32_t x, int32_t y, int32_t width, int32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
-			 XDG_SURFACE_SET_WINDOW_GEOMETRY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, x, y, width, height);
-}
-
-/**
- * @ingroup iface_xdg_surface
- *
- * When a configure event is received, if a client commits the
- * surface in response to the configure event, then the client
- * must make an ack_configure request sometime before the commit
- * request, passing along the serial of the configure event.
- *
- * For instance, for toplevel surfaces the compositor might use this
- * information to move a surface to the top left only when the client has
- * drawn itself for the maximized or fullscreen state.
- *
- * If the client receives multiple configure events before it
- * can respond to one, it only has to ack the last configure event.
- * Acking a configure event that was never sent raises an invalid_serial
- * error.
- *
- * A client is not required to commit immediately after sending
- * an ack_configure request - it may even ack_configure several times
- * before its next surface commit.
- *
- * A client may send multiple ack_configure requests before committing, but
- * only the last request sent before a commit indicates which configure
- * event the client really is responding to.
- *
- * Sending an ack_configure request consumes the serial number sent with
- * the request, as well as serial numbers sent by all configure events
- * sent on this xdg_surface prior to the configure event referenced by
- * the committed serial.
- *
- * It is an error to issue multiple ack_configure requests referencing a
- * serial from the same configure event, or to issue an ack_configure
- * request referencing a serial from a configure event issued before the
- * event identified by the last ack_configure request for the same
- * xdg_surface. Doing so will raise an invalid_serial error.
- */
-static inline void
-xdg_surface_ack_configure(struct xdg_surface *xdg_surface, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_surface,
-			 XDG_SURFACE_ACK_CONFIGURE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_surface), 0, serial);
-}
-
-#ifndef XDG_TOPLEVEL_ERROR_ENUM
-#define XDG_TOPLEVEL_ERROR_ENUM
-enum xdg_toplevel_error {
-	/**
-	 * provided value is         not a valid variant of the resize_edge enum
-	 */
-	XDG_TOPLEVEL_ERROR_INVALID_RESIZE_EDGE = 0,
-	/**
-	 * invalid parent toplevel
-	 */
-	XDG_TOPLEVEL_ERROR_INVALID_PARENT = 1,
-	/**
-	 * client provided an invalid min or max size
-	 */
-	XDG_TOPLEVEL_ERROR_INVALID_SIZE = 2,
-};
-#endif /* XDG_TOPLEVEL_ERROR_ENUM */
-
-#ifndef XDG_TOPLEVEL_RESIZE_EDGE_ENUM
-#define XDG_TOPLEVEL_RESIZE_EDGE_ENUM
-/**
- * @ingroup iface_xdg_toplevel
- * edge values for resizing
- *
- * These values are used to indicate which edge of a surface
- * is being dragged in a resize operation.
- */
-enum xdg_toplevel_resize_edge {
-	XDG_TOPLEVEL_RESIZE_EDGE_NONE = 0,
-	XDG_TOPLEVEL_RESIZE_EDGE_TOP = 1,
-	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM = 2,
-	XDG_TOPLEVEL_RESIZE_EDGE_LEFT = 4,
-	XDG_TOPLEVEL_RESIZE_EDGE_TOP_LEFT = 5,
-	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_LEFT = 6,
-	XDG_TOPLEVEL_RESIZE_EDGE_RIGHT = 8,
-	XDG_TOPLEVEL_RESIZE_EDGE_TOP_RIGHT = 9,
-	XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM_RIGHT = 10,
-};
-#endif /* XDG_TOPLEVEL_RESIZE_EDGE_ENUM */
-
-#ifndef XDG_TOPLEVEL_STATE_ENUM
-#define XDG_TOPLEVEL_STATE_ENUM
-/**
- * @ingroup iface_xdg_toplevel
- * types of state on the surface
- *
- * The different state values used on the surface. This is designed for
- * state values like maximized, fullscreen. It is paired with the
- * configure event to ensure that both the client and the compositor
- * setting the state can be synchronized.
- *
- * States set in this way are double-buffered. They will get applied on
- * the next commit.
- */
-enum xdg_toplevel_state {
-	/**
-	 * the surface is maximized
-	 * the surface is maximized
-	 *
-	 * The surface is maximized. The window geometry specified in the
-	 * configure event must be obeyed by the client.
-	 *
-	 * The client should draw without shadow or other decoration
-	 * outside of the window geometry.
-	 */
-	XDG_TOPLEVEL_STATE_MAXIMIZED = 1,
-	/**
-	 * the surface is fullscreen
-	 * the surface is fullscreen
-	 *
-	 * The surface is fullscreen. The window geometry specified in
-	 * the configure event is a maximum; the client cannot resize
-	 * beyond it. For a surface to cover the whole fullscreened area,
-	 * the geometry dimensions must be obeyed by the client. For more
-	 * details, see xdg_toplevel.set_fullscreen.
-	 */
-	XDG_TOPLEVEL_STATE_FULLSCREEN = 2,
-	/**
-	 * the surface is being resized
-	 * the surface is being resized
-	 *
-	 * The surface is being resized. The window geometry specified in
-	 * the configure event is a maximum; the client cannot resize
-	 * beyond it. Clients that have aspect ratio or cell sizing
-	 * configuration can use a smaller size, however.
-	 */
-	XDG_TOPLEVEL_STATE_RESIZING = 3,
-	/**
-	 * the surface is now activated
-	 * the surface is now activated
-	 *
-	 * Client window decorations should be painted as if the window
-	 * is active. Do not assume this means that the window actually has
-	 * keyboard or pointer focus.
-	 */
-	XDG_TOPLEVEL_STATE_ACTIVATED = 4,
-	/**
-	 * the surfaces left edge is tiled
-	 *
-	 * The window is currently in a tiled layout and the left edge is
-	 * considered to be adjacent to another part of the tiling grid.
-	 * @since 2
-	 */
-	XDG_TOPLEVEL_STATE_TILED_LEFT = 5,
-	/**
-	 * the surfaces right edge is tiled
-	 *
-	 * The window is currently in a tiled layout and the right edge
-	 * is considered to be adjacent to another part of the tiling grid.
-	 * @since 2
-	 */
-	XDG_TOPLEVEL_STATE_TILED_RIGHT = 6,
-	/**
-	 * the surfaces top edge is tiled
-	 *
-	 * The window is currently in a tiled layout and the top edge is
-	 * considered to be adjacent to another part of the tiling grid.
-	 * @since 2
-	 */
-	XDG_TOPLEVEL_STATE_TILED_TOP = 7,
-	/**
-	 * the surfaces bottom edge is tiled
-	 *
-	 * The window is currently in a tiled layout and the bottom edge
-	 * is considered to be adjacent to another part of the tiling grid.
-	 * @since 2
-	 */
-	XDG_TOPLEVEL_STATE_TILED_BOTTOM = 8,
-};
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_STATE_TILED_LEFT_SINCE_VERSION 2
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_STATE_TILED_RIGHT_SINCE_VERSION 2
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_STATE_TILED_TOP_SINCE_VERSION 2
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_STATE_TILED_BOTTOM_SINCE_VERSION 2
-#endif /* XDG_TOPLEVEL_STATE_ENUM */
-
-#ifndef XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
-#define XDG_TOPLEVEL_WM_CAPABILITIES_ENUM
-enum xdg_toplevel_wm_capabilities {
-	/**
-	 * show_window_menu is available
-	 */
-	XDG_TOPLEVEL_WM_CAPABILITIES_WINDOW_MENU = 1,
-	/**
-	 * set_maximized and unset_maximized are available
-	 */
-	XDG_TOPLEVEL_WM_CAPABILITIES_MAXIMIZE = 2,
-	/**
-	 * set_fullscreen and unset_fullscreen are available
-	 */
-	XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN = 3,
-	/**
-	 * set_minimized is available
-	 */
-	XDG_TOPLEVEL_WM_CAPABILITIES_MINIMIZE = 4,
-};
-#endif /* XDG_TOPLEVEL_WM_CAPABILITIES_ENUM */
-
-/**
- * @ingroup iface_xdg_toplevel
- * @struct xdg_toplevel_listener
- */
-struct xdg_toplevel_listener {
-	/**
-	 * suggest a surface change
-	 *
-	 * This configure event asks the client to resize its toplevel
-	 * surface or to change its state. The configured state should not
-	 * be applied immediately. See xdg_surface.configure for details.
-	 *
-	 * The width and height arguments specify a hint to the window
-	 * about how its surface should be resized in window geometry
-	 * coordinates. See set_window_geometry.
-	 *
-	 * If the width or height arguments are zero, it means the client
-	 * should decide its own window dimension. This may happen when the
-	 * compositor needs to configure the state of the surface but
-	 * doesn't have any information about any previous or expected
-	 * dimension.
-	 *
-	 * The states listed in the event specify how the width/height
-	 * arguments should be interpreted, and possibly how it should be
-	 * drawn.
-	 *
-	 * Clients must send an ack_configure in response to this event.
-	 * See xdg_surface.configure and xdg_surface.ack_configure for
-	 * details.
-	 */
-	void (*configure)(void *data,
-			  struct xdg_toplevel *xdg_toplevel,
-			  int32_t width,
-			  int32_t height,
-			  struct wl_array *states);
-	/**
-	 * surface wants to be closed
-	 *
-	 * The close event is sent by the compositor when the user wants
-	 * the surface to be closed. This should be equivalent to the user
-	 * clicking the close button in client-side decorations, if your
-	 * application has any.
-	 *
-	 * This is only a request that the user intends to close the
-	 * window. The client may choose to ignore this request, or show a
-	 * dialog to ask the user to save their data, etc.
-	 */
-	void (*close)(void *data,
-		      struct xdg_toplevel *xdg_toplevel);
-	/**
-	 * recommended window geometry bounds
-	 *
-	 * The configure_bounds event may be sent prior to a
-	 * xdg_toplevel.configure event to communicate the bounds a window
-	 * geometry size is recommended to constrain to.
-	 *
-	 * The passed width and height are in surface coordinate space. If
-	 * width and height are 0, it means bounds is unknown and
-	 * equivalent to as if no configure_bounds event was ever sent for
-	 * this surface.
-	 *
-	 * The bounds can for example correspond to the size of a monitor
-	 * excluding any panels or other shell components, so that a
-	 * surface isn't created in a way that it cannot fit.
-	 *
-	 * The bounds may change at any point, and in such a case, a new
-	 * xdg_toplevel.configure_bounds will be sent, followed by
-	 * xdg_toplevel.configure and xdg_surface.configure.
-	 * @since 4
-	 */
-	void (*configure_bounds)(void *data,
-				 struct xdg_toplevel *xdg_toplevel,
-				 int32_t width,
-				 int32_t height);
-	/**
-	 * compositor capabilities
-	 *
-	 * This event advertises the capabilities supported by the
-	 * compositor. If a capability isn't supported, clients should hide
-	 * or disable the UI elements that expose this functionality. For
-	 * instance, if the compositor doesn't advertise support for
-	 * minimized toplevels, a button triggering the set_minimized
-	 * request should not be displayed.
-	 *
-	 * The compositor will ignore requests it doesn't support. For
-	 * instance, a compositor which doesn't advertise support for
-	 * minimized will ignore set_minimized requests.
-	 *
-	 * Compositors must send this event once before the first
-	 * xdg_surface.configure event. When the capabilities change,
-	 * compositors must send this event again and then send an
-	 * xdg_surface.configure event.
-	 *
-	 * The configured state should not be applied immediately. See
-	 * xdg_surface.configure for details.
-	 *
-	 * The capabilities are sent as an array of 32-bit unsigned
-	 * integers in native endianness.
-	 * @param capabilities array of 32-bit capabilities
-	 * @since 5
-	 */
-	void (*wm_capabilities)(void *data,
-				struct xdg_toplevel *xdg_toplevel,
-				struct wl_array *capabilities);
-};
-
-/**
- * @ingroup iface_xdg_toplevel
- */
-static inline int
-xdg_toplevel_add_listener(struct xdg_toplevel *xdg_toplevel,
-			  const struct xdg_toplevel_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) xdg_toplevel,
-				     (void (**)(void)) listener, data);
-}
-
-#define XDG_TOPLEVEL_DESTROY 0
-#define XDG_TOPLEVEL_SET_PARENT 1
-#define XDG_TOPLEVEL_SET_TITLE 2
-#define XDG_TOPLEVEL_SET_APP_ID 3
-#define XDG_TOPLEVEL_SHOW_WINDOW_MENU 4
-#define XDG_TOPLEVEL_MOVE 5
-#define XDG_TOPLEVEL_RESIZE 6
-#define XDG_TOPLEVEL_SET_MAX_SIZE 7
-#define XDG_TOPLEVEL_SET_MIN_SIZE 8
-#define XDG_TOPLEVEL_SET_MAXIMIZED 9
-#define XDG_TOPLEVEL_UNSET_MAXIMIZED 10
-#define XDG_TOPLEVEL_SET_FULLSCREEN 11
-#define XDG_TOPLEVEL_UNSET_FULLSCREEN 12
-#define XDG_TOPLEVEL_SET_MINIMIZED 13
-
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_CONFIGURE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_CLOSE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_CONFIGURE_BOUNDS_SINCE_VERSION 4
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_WM_CAPABILITIES_SINCE_VERSION 5
-
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_PARENT_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_TITLE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_APP_ID_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SHOW_WINDOW_MENU_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_MOVE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_RESIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_MAX_SIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_MIN_SIZE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_MAXIMIZED_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_UNSET_MAXIMIZED_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_FULLSCREEN_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_UNSET_FULLSCREEN_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_toplevel
- */
-#define XDG_TOPLEVEL_SET_MINIMIZED_SINCE_VERSION 1
-
-/** @ingroup iface_xdg_toplevel */
-static inline void
-xdg_toplevel_set_user_data(struct xdg_toplevel *xdg_toplevel, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) xdg_toplevel, user_data);
-}
-
-/** @ingroup iface_xdg_toplevel */
-static inline void *
-xdg_toplevel_get_user_data(struct xdg_toplevel *xdg_toplevel)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) xdg_toplevel);
-}
-
-static inline uint32_t
-xdg_toplevel_get_version(struct xdg_toplevel *xdg_toplevel)
-{
-	return wl_proxy_get_version((struct wl_proxy *) xdg_toplevel);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * This request destroys the role surface and unmaps the surface;
- * see "Unmapping" behavior in interface section for details.
- */
-static inline void
-xdg_toplevel_destroy(struct xdg_toplevel *xdg_toplevel)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Set the "parent" of this surface. This surface should be stacked
- * above the parent surface and all other ancestor surfaces.
- *
- * Parent surfaces should be set on dialogs, toolboxes, or other
- * "auxiliary" surfaces, so that the parent is raised when the dialog
- * is raised.
- *
- * Setting a null parent for a child surface unsets its parent. Setting
- * a null parent for a surface which currently has no parent is a no-op.
- *
- * Only mapped surfaces can have child surfaces. Setting a parent which
- * is not mapped is equivalent to setting a null parent. If a surface
- * becomes unmapped, its children's parent is set to the parent of
- * the now-unmapped surface. If the now-unmapped surface has no parent,
- * its children's parent is unset. If the now-unmapped surface becomes
- * mapped again, its parent-child relationship is not restored.
- *
- * The parent toplevel must not be one of the child toplevel's
- * descendants, and the parent must be different from the child toplevel,
- * otherwise the invalid_parent protocol error is raised.
- */
-static inline void
-xdg_toplevel_set_parent(struct xdg_toplevel *xdg_toplevel, struct xdg_toplevel *parent)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_PARENT, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, parent);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Set a short title for the surface.
- *
- * This string may be used to identify the surface in a task bar,
- * window list, or other user interface elements provided by the
- * compositor.
- *
- * The string must be encoded in UTF-8.
- */
-static inline void
-xdg_toplevel_set_title(struct xdg_toplevel *xdg_toplevel, const char *title)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_TITLE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, title);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Set an application identifier for the surface.
- *
- * The app ID identifies the general class of applications to which
- * the surface belongs. The compositor can use this to group multiple
- * surfaces together, or to determine how to launch a new application.
- *
- * For D-Bus activatable applications, the app ID is used as the D-Bus
- * service name.
- *
- * The compositor shell will try to group application surfaces together
- * by their app ID. As a best practice, it is suggested to select app
- * ID's that match the basename of the application's .desktop file.
- * For example, "org.freedesktop.FooViewer" where the .desktop file is
- * "org.freedesktop.FooViewer.desktop".
- *
- * Like other properties, a set_app_id request can be sent after the
- * xdg_toplevel has been mapped to update the property.
- *
- * See the desktop-entry specification [0] for more details on
- * application identifiers and how they relate to well-known D-Bus
- * names and .desktop files.
- *
- * [0] https://standards.freedesktop.org/desktop-entry-spec/
- */
-static inline void
-xdg_toplevel_set_app_id(struct xdg_toplevel *xdg_toplevel, const char *app_id)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_APP_ID, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, app_id);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Clients implementing client-side decorations might want to show
- * a context menu when right-clicking on the decorations, giving the
- * user a menu that they can use to maximize or minimize the window.
- *
- * This request asks the compositor to pop up such a window menu at
- * the given position, relative to the local surface coordinates of
- * the parent surface. There are no guarantees as to what menu items
- * the window menu contains, or even if a window menu will be drawn
- * at all.
- *
- * This request must be used in response to some sort of user action
- * like a button press, key press, or touch down event.
- */
-static inline void
-xdg_toplevel_show_window_menu(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, int32_t x, int32_t y)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SHOW_WINDOW_MENU, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, x, y);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Start an interactive, user-driven move of the surface.
- *
- * This request must be used in response to some sort of user action
- * like a button press, key press, or touch down event. The passed
- * serial is used to determine the type of interactive move (touch,
- * pointer, etc).
- *
- * The server may ignore move requests depending on the state of
- * the surface (e.g. fullscreen or maximized), or if the passed serial
- * is no longer valid.
- *
- * If triggered, the surface will lose the focus of the device
- * (wl_pointer, wl_touch, etc) used for the move. It is up to the
- * compositor to visually indicate that the move is taking place, such as
- * updating a pointer cursor, during the move. There is no guarantee
- * that the device focus will return when the move is completed.
- */
-static inline void
-xdg_toplevel_move(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_MOVE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Start a user-driven, interactive resize of the surface.
- *
- * This request must be used in response to some sort of user action
- * like a button press, key press, or touch down event. The passed
- * serial is used to determine the type of interactive resize (touch,
- * pointer, etc).
- *
- * The server may ignore resize requests depending on the state of
- * the surface (e.g. fullscreen or maximized).
- *
- * If triggered, the client will receive configure events with the
- * "resize" state enum value and the expected sizes. See the "resize"
- * enum value for more details about what is required. The client
- * must also acknowledge configure events using "ack_configure". After
- * the resize is completed, the client will receive another "configure"
- * event without the resize state.
- *
- * If triggered, the surface also will lose the focus of the device
- * (wl_pointer, wl_touch, etc) used for the resize. It is up to the
- * compositor to visually indicate that the resize is taking place,
- * such as updating a pointer cursor, during the resize. There is no
- * guarantee that the device focus will return when the resize is
- * completed.
- *
- * The edges parameter specifies how the surface should be resized, and
- * is one of the values of the resize_edge enum. Values not matching
- * a variant of the enum will cause a protocol error. The compositor
- * may use this information to update the surface position for example
- * when dragging the top left corner. The compositor may also use
- * this information to adapt its behavior, e.g. choose an appropriate
- * cursor image.
- */
-static inline void
-xdg_toplevel_resize(struct xdg_toplevel *xdg_toplevel, struct wl_seat *seat, uint32_t serial, uint32_t edges)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_RESIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, seat, serial, edges);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Set a maximum size for the window.
- *
- * The client can specify a maximum size so that the compositor does
- * not try to configure the window beyond this size.
- *
- * The width and height arguments are in window geometry coordinates.
- * See xdg_surface.set_window_geometry.
- *
- * Values set in this way are double-buffered. They will get applied
- * on the next commit.
- *
- * The compositor can use this information to allow or disallow
- * different states like maximize or fullscreen and draw accurate
- * animations.
- *
- * Similarly, a tiling window manager may use this information to
- * place and resize client windows in a more effective way.
- *
- * The client should not rely on the compositor to obey the maximum
- * size. The compositor may decide to ignore the values set by the
- * client and request a larger size.
- *
- * If never set, or a value of zero in the request, means that the
- * client has no expected maximum size in the given dimension.
- * As a result, a client wishing to reset the maximum size
- * to an unspecified state can use zero for width and height in the
- * request.
- *
- * Requesting a maximum size to be smaller than the minimum size of
- * a surface is illegal and will result in an invalid_size error.
- *
- * The width and height must be greater than or equal to zero. Using
- * strictly negative values for width or height will result in a
- * invalid_size error.
- */
-static inline void
-xdg_toplevel_set_max_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_MAX_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Set a minimum size for the window.
- *
- * The client can specify a minimum size so that the compositor does
- * not try to configure the window below this size.
- *
- * The width and height arguments are in window geometry coordinates.
- * See xdg_surface.set_window_geometry.
- *
- * Values set in this way are double-buffered. They will get applied
- * on the next commit.
- *
- * The compositor can use this information to allow or disallow
- * different states like maximize or fullscreen and draw accurate
- * animations.
- *
- * Similarly, a tiling window manager may use this information to
- * place and resize client windows in a more effective way.
- *
- * The client should not rely on the compositor to obey the minimum
- * size. The compositor may decide to ignore the values set by the
- * client and request a smaller size.
- *
- * If never set, or a value of zero in the request, means that the
- * client has no expected minimum size in the given dimension.
- * As a result, a client wishing to reset the minimum size
- * to an unspecified state can use zero for width and height in the
- * request.
- *
- * Requesting a minimum size to be larger than the maximum size of
- * a surface is illegal and will result in an invalid_size error.
- *
- * The width and height must be greater than or equal to zero. Using
- * strictly negative values for width and height will result in a
- * invalid_size error.
- */
-static inline void
-xdg_toplevel_set_min_size(struct xdg_toplevel *xdg_toplevel, int32_t width, int32_t height)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_MIN_SIZE, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, width, height);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Maximize the surface.
- *
- * After requesting that the surface should be maximized, the compositor
- * will respond by emitting a configure event. Whether this configure
- * actually sets the window maximized is subject to compositor policies.
- * The client must then update its content, drawing in the configured
- * state. The client must also acknowledge the configure when committing
- * the new content (see ack_configure).
- *
- * It is up to the compositor to decide how and where to maximize the
- * surface, for example which output and what region of the screen should
- * be used.
- *
- * If the surface was already maximized, the compositor will still emit
- * a configure event with the "maximized" state.
- *
- * If the surface is in a fullscreen state, this request has no direct
- * effect. It may alter the state the surface is returned to when
- * unmaximized unless overridden by the compositor.
- */
-static inline void
-xdg_toplevel_set_maximized(struct xdg_toplevel *xdg_toplevel)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Unmaximize the surface.
- *
- * After requesting that the surface should be unmaximized, the compositor
- * will respond by emitting a configure event. Whether this actually
- * un-maximizes the window is subject to compositor policies.
- * If available and applicable, the compositor will include the window
- * geometry dimensions the window had prior to being maximized in the
- * configure event. The client must then update its content, drawing it in
- * the configured state. The client must also acknowledge the configure
- * when committing the new content (see ack_configure).
- *
- * It is up to the compositor to position the surface after it was
- * unmaximized; usually the position the surface had before maximizing, if
- * applicable.
- *
- * If the surface was already not maximized, the compositor will still
- * emit a configure event without the "maximized" state.
- *
- * If the surface is in a fullscreen state, this request has no direct
- * effect. It may alter the state the surface is returned to when
- * unmaximized unless overridden by the compositor.
- */
-static inline void
-xdg_toplevel_unset_maximized(struct xdg_toplevel *xdg_toplevel)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_UNSET_MAXIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Make the surface fullscreen.
- *
- * After requesting that the surface should be fullscreened, the
- * compositor will respond by emitting a configure event. Whether the
- * client is actually put into a fullscreen state is subject to compositor
- * policies. The client must also acknowledge the configure when
- * committing the new content (see ack_configure).
- *
- * The output passed by the request indicates the client's preference as
- * to which display it should be set fullscreen on. If this value is NULL,
- * it's up to the compositor to choose which display will be used to map
- * this surface.
- *
- * If the surface doesn't cover the whole output, the compositor will
- * position the surface in the center of the output and compensate with
- * with border fill covering the rest of the output. The content of the
- * border fill is undefined, but should be assumed to be in some way that
- * attempts to blend into the surrounding area (e.g. solid black).
- *
- * If the fullscreened surface is not opaque, the compositor must make
- * sure that other screen content not part of the same surface tree (made
- * up of subsurfaces, popups or similarly coupled surfaces) are not
- * visible below the fullscreened surface.
- */
-static inline void
-xdg_toplevel_set_fullscreen(struct xdg_toplevel *xdg_toplevel, struct wl_output *output)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0, output);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Make the surface no longer fullscreen.
- *
- * After requesting that the surface should be unfullscreened, the
- * compositor will respond by emitting a configure event.
- * Whether this actually removes the fullscreen state of the client is
- * subject to compositor policies.
- *
- * Making a surface unfullscreen sets states for the surface based on the following:
- * * the state(s) it may have had before becoming fullscreen
- * * any state(s) decided by the compositor
- * * any state(s) requested by the client while the surface was fullscreen
- *
- * The compositor may include the previous window geometry dimensions in
- * the configure event, if applicable.
- *
- * The client must also acknowledge the configure when committing the new
- * content (see ack_configure).
- */
-static inline void
-xdg_toplevel_unset_fullscreen(struct xdg_toplevel *xdg_toplevel)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_UNSET_FULLSCREEN, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
-}
-
-/**
- * @ingroup iface_xdg_toplevel
- *
- * Request that the compositor minimize your surface. There is no
- * way to know if the surface is currently minimized, nor is there
- * any way to unset minimization on this surface.
- *
- * If you are looking to throttle redrawing when minimized, please
- * instead use the wl_surface.frame event for this, as this will
- * also work with live previews on windows in Alt-Tab, Expose or
- * similar compositor features.
- */
-static inline void
-xdg_toplevel_set_minimized(struct xdg_toplevel *xdg_toplevel)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_toplevel,
-			 XDG_TOPLEVEL_SET_MINIMIZED, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_toplevel), 0);
-}
-
-#ifndef XDG_POPUP_ERROR_ENUM
-#define XDG_POPUP_ERROR_ENUM
-enum xdg_popup_error {
-	/**
-	 * tried to grab after being mapped
-	 */
-	XDG_POPUP_ERROR_INVALID_GRAB = 0,
-};
-#endif /* XDG_POPUP_ERROR_ENUM */
-
-/**
- * @ingroup iface_xdg_popup
- * @struct xdg_popup_listener
- */
-struct xdg_popup_listener {
-	/**
-	 * configure the popup surface
-	 *
-	 * This event asks the popup surface to configure itself given
-	 * the configuration. The configured state should not be applied
-	 * immediately. See xdg_surface.configure for details.
-	 *
-	 * The x and y arguments represent the position the popup was
-	 * placed at given the xdg_positioner rule, relative to the upper
-	 * left corner of the window geometry of the parent surface.
-	 *
-	 * For version 2 or older, the configure event for an xdg_popup is
-	 * only ever sent once for the initial configuration. Starting with
-	 * version 3, it may be sent again if the popup is setup with an
-	 * xdg_positioner with set_reactive requested, or in response to
-	 * xdg_popup.reposition requests.
-	 * @param x x position relative to parent surface window geometry
-	 * @param y y position relative to parent surface window geometry
-	 * @param width window geometry width
-	 * @param height window geometry height
-	 */
-	void (*configure)(void *data,
-			  struct xdg_popup *xdg_popup,
-			  int32_t x,
-			  int32_t y,
-			  int32_t width,
-			  int32_t height);
-	/**
-	 * popup interaction is done
-	 *
-	 * The popup_done event is sent out when a popup is dismissed by
-	 * the compositor. The client should destroy the xdg_popup object
-	 * at this point.
-	 */
-	void (*popup_done)(void *data,
-			   struct xdg_popup *xdg_popup);
-	/**
-	 * signal the completion of a repositioned request
-	 *
-	 * The repositioned event is sent as part of a popup
-	 * configuration sequence, together with xdg_popup.configure and
-	 * lastly xdg_surface.configure to notify the completion of a
-	 * reposition request.
-	 *
-	 * The repositioned event is to notify about the completion of a
-	 * xdg_popup.reposition request. The token argument is the token
-	 * passed in the xdg_popup.reposition request.
-	 *
-	 * Immediately after this event is emitted, xdg_popup.configure and
-	 * xdg_surface.configure will be sent with the updated size and
-	 * position, as well as a new configure serial.
-	 *
-	 * The client should optionally update the content of the popup,
-	 * but must acknowledge the new popup configuration for the new
-	 * position to take effect. See xdg_surface.ack_configure for
-	 * details.
-	 * @param token reposition request token
-	 * @since 3
-	 */
-	void (*repositioned)(void *data,
-			     struct xdg_popup *xdg_popup,
-			     uint32_t token);
-};
-
-/**
- * @ingroup iface_xdg_popup
- */
-static inline int
-xdg_popup_add_listener(struct xdg_popup *xdg_popup,
-		       const struct xdg_popup_listener *listener, void *data)
-{
-	return wl_proxy_add_listener((struct wl_proxy *) xdg_popup,
-				     (void (**)(void)) listener, data);
-}
-
-#define XDG_POPUP_DESTROY 0
-#define XDG_POPUP_GRAB 1
-#define XDG_POPUP_REPOSITION 2
-
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_CONFIGURE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_POPUP_DONE_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_REPOSITIONED_SINCE_VERSION 3
-
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_DESTROY_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_GRAB_SINCE_VERSION 1
-/**
- * @ingroup iface_xdg_popup
- */
-#define XDG_POPUP_REPOSITION_SINCE_VERSION 3
-
-/** @ingroup iface_xdg_popup */
-static inline void
-xdg_popup_set_user_data(struct xdg_popup *xdg_popup, void *user_data)
-{
-	wl_proxy_set_user_data((struct wl_proxy *) xdg_popup, user_data);
-}
-
-/** @ingroup iface_xdg_popup */
-static inline void *
-xdg_popup_get_user_data(struct xdg_popup *xdg_popup)
-{
-	return wl_proxy_get_user_data((struct wl_proxy *) xdg_popup);
-}
-
-static inline uint32_t
-xdg_popup_get_version(struct xdg_popup *xdg_popup)
-{
-	return wl_proxy_get_version((struct wl_proxy *) xdg_popup);
-}
-
-/**
- * @ingroup iface_xdg_popup
- *
- * This destroys the popup. Explicitly destroying the xdg_popup
- * object will also dismiss the popup, and unmap the surface.
- *
- * If this xdg_popup is not the "topmost" popup, a protocol error
- * will be sent.
- */
-static inline void
-xdg_popup_destroy(struct xdg_popup *xdg_popup)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
-			 XDG_POPUP_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), WL_MARSHAL_FLAG_DESTROY);
-}
-
-/**
- * @ingroup iface_xdg_popup
- *
- * This request makes the created popup take an explicit grab. An explicit
- * grab will be dismissed when the user dismisses the popup, or when the
- * client destroys the xdg_popup. This can be done by the user clicking
- * outside the surface, using the keyboard, or even locking the screen
- * through closing the lid or a timeout.
- *
- * If the compositor denies the grab, the popup will be immediately
- * dismissed.
- *
- * This request must be used in response to some sort of user action like a
- * button press, key press, or touch down event. The serial number of the
- * event should be passed as 'serial'.
- *
- * The parent of a grabbing popup must either be an xdg_toplevel surface or
- * another xdg_popup with an explicit grab. If the parent is another
- * xdg_popup it means that the popups are nested, with this popup now being
- * the topmost popup.
- *
- * Nested popups must be destroyed in the reverse order they were created
- * in, e.g. the only popup you are allowed to destroy at all times is the
- * topmost one.
- *
- * When compositors choose to dismiss a popup, they may dismiss every
- * nested grabbing popup as well. When a compositor dismisses popups, it
- * will follow the same dismissing order as required from the client.
- *
- * If the topmost grabbing popup is destroyed, the grab will be returned to
- * the parent of the popup, if that parent previously had an explicit grab.
- *
- * If the parent is a grabbing popup which has already been dismissed, this
- * popup will be immediately dismissed. If the parent is a popup that did
- * not take an explicit grab, an error will be raised.
- *
- * During a popup grab, the client owning the grab will receive pointer
- * and touch events for all their surfaces as normal (similar to an
- * "owner-events" grab in X11 parlance), while the top most grabbing popup
- * will always have keyboard focus.
- */
-static inline void
-xdg_popup_grab(struct xdg_popup *xdg_popup, struct wl_seat *seat, uint32_t serial)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
-			 XDG_POPUP_GRAB, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, seat, serial);
-}
-
-/**
- * @ingroup iface_xdg_popup
- *
- * Reposition an already-mapped popup. The popup will be placed given the
- * details in the passed xdg_positioner object, and a
- * xdg_popup.repositioned followed by xdg_popup.configure and
- * xdg_surface.configure will be emitted in response. Any parameters set
- * by the previous positioner will be discarded.
- *
- * The passed token will be sent in the corresponding
- * xdg_popup.repositioned event. The new popup position will not take
- * effect until the corresponding configure event is acknowledged by the
- * client. See xdg_popup.repositioned for details. The token itself is
- * opaque, and has no other special meaning.
- *
- * If multiple reposition requests are sent, the compositor may skip all
- * but the last one.
- *
- * If the popup is repositioned in response to a configure event for its
- * parent, the client should send an xdg_positioner.set_parent_configure
- * and possibly an xdg_positioner.set_parent_size request to allow the
- * compositor to properly constrain the popup.
- *
- * If the popup is repositioned together with a parent that is being
- * resized, but not in response to a configure event, the client should
- * send an xdg_positioner.set_parent_size request.
- */
-static inline void
-xdg_popup_reposition(struct xdg_popup *xdg_popup, struct xdg_positioner *positioner, uint32_t token)
-{
-	wl_proxy_marshal_flags((struct wl_proxy *) xdg_popup,
-			 XDG_POPUP_REPOSITION, NULL, wl_proxy_get_version((struct wl_proxy *) xdg_popup), 0, positioner, token);
-}
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/xdg-shell-protocol.c b/src/xdg-shell-protocol.c
deleted file mode 100644
index d2fde49..0000000
--- a/src/xdg-shell-protocol.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/* Generated by wayland-scanner 1.21.0 */
-
-/*
- * Copyright  2008-2013 Kristian Hgsberg
- * Copyright  2013      Rafael Antognolli
- * Copyright  2013      Jasper St. Pierre
- * Copyright  2010-2013 Intel Corporation
- * Copyright  2015-2017 Samsung Electronics Co., Ltd
- * Copyright  2015-2017 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include <stdlib.h>
-#include <stdint.h>
-#include "wayland-util.h"
-
-#ifndef __has_attribute
-# define __has_attribute(x) 0  /* Compatibility with non-clang compilers. */
-#endif
-
-#if (__has_attribute(visibility) || defined(__GNUC__) && __GNUC__ >= 4)
-#define WL_PRIVATE __attribute__ ((visibility("hidden")))
-#else
-#define WL_PRIVATE
-#endif
-
-extern const struct wl_interface wl_output_interface;
-extern const struct wl_interface wl_seat_interface;
-extern const struct wl_interface wl_surface_interface;
-extern const struct wl_interface xdg_popup_interface;
-extern const struct wl_interface xdg_positioner_interface;
-extern const struct wl_interface xdg_surface_interface;
-extern const struct wl_interface xdg_toplevel_interface;
-
-static const struct wl_interface *xdg_shell_types[] = {
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	&xdg_positioner_interface,
-	&xdg_surface_interface,
-	&wl_surface_interface,
-	&xdg_toplevel_interface,
-	&xdg_popup_interface,
-	&xdg_surface_interface,
-	&xdg_positioner_interface,
-	&xdg_toplevel_interface,
-	&wl_seat_interface,
-	NULL,
-	NULL,
-	NULL,
-	&wl_seat_interface,
-	NULL,
-	&wl_seat_interface,
-	NULL,
-	NULL,
-	&wl_output_interface,
-	&wl_seat_interface,
-	NULL,
-	&xdg_positioner_interface,
-	NULL,
-};
-
-static const struct wl_message xdg_wm_base_requests[] = {
-	{ "destroy", "", xdg_shell_types + 0 },
-	{ "create_positioner", "n", xdg_shell_types + 4 },
-	{ "get_xdg_surface", "no", xdg_shell_types + 5 },
-	{ "pong", "u", xdg_shell_types + 0 },
-};
-
-static const struct wl_message xdg_wm_base_events[] = {
-	{ "ping", "u", xdg_shell_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface xdg_wm_base_interface = {
-	"xdg_wm_base", 5,
-	4, xdg_wm_base_requests,
-	1, xdg_wm_base_events,
-};
-
-static const struct wl_message xdg_positioner_requests[] = {
-	{ "destroy", "", xdg_shell_types + 0 },
-	{ "set_size", "ii", xdg_shell_types + 0 },
-	{ "set_anchor_rect", "iiii", xdg_shell_types + 0 },
-	{ "set_anchor", "u", xdg_shell_types + 0 },
-	{ "set_gravity", "u", xdg_shell_types + 0 },
-	{ "set_constraint_adjustment", "u", xdg_shell_types + 0 },
-	{ "set_offset", "ii", xdg_shell_types + 0 },
-	{ "set_reactive", "3", xdg_shell_types + 0 },
-	{ "set_parent_size", "3ii", xdg_shell_types + 0 },
-	{ "set_parent_configure", "3u", xdg_shell_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface xdg_positioner_interface = {
-	"xdg_positioner", 5,
-	10, xdg_positioner_requests,
-	0, NULL,
-};
-
-static const struct wl_message xdg_surface_requests[] = {
-	{ "destroy", "", xdg_shell_types + 0 },
-	{ "get_toplevel", "n", xdg_shell_types + 7 },
-	{ "get_popup", "n?oo", xdg_shell_types + 8 },
-	{ "set_window_geometry", "iiii", xdg_shell_types + 0 },
-	{ "ack_configure", "u", xdg_shell_types + 0 },
-};
-
-static const struct wl_message xdg_surface_events[] = {
-	{ "configure", "u", xdg_shell_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface xdg_surface_interface = {
-	"xdg_surface", 5,
-	5, xdg_surface_requests,
-	1, xdg_surface_events,
-};
-
-static const struct wl_message xdg_toplevel_requests[] = {
-	{ "destroy", "", xdg_shell_types + 0 },
-	{ "set_parent", "?o", xdg_shell_types + 11 },
-	{ "set_title", "s", xdg_shell_types + 0 },
-	{ "set_app_id", "s", xdg_shell_types + 0 },
-	{ "show_window_menu", "ouii", xdg_shell_types + 12 },
-	{ "move", "ou", xdg_shell_types + 16 },
-	{ "resize", "ouu", xdg_shell_types + 18 },
-	{ "set_max_size", "ii", xdg_shell_types + 0 },
-	{ "set_min_size", "ii", xdg_shell_types + 0 },
-	{ "set_maximized", "", xdg_shell_types + 0 },
-	{ "unset_maximized", "", xdg_shell_types + 0 },
-	{ "set_fullscreen", "?o", xdg_shell_types + 21 },
-	{ "unset_fullscreen", "", xdg_shell_types + 0 },
-	{ "set_minimized", "", xdg_shell_types + 0 },
-};
-
-static const struct wl_message xdg_toplevel_events[] = {
-	{ "configure", "iia", xdg_shell_types + 0 },
-	{ "close", "", xdg_shell_types + 0 },
-	{ "configure_bounds", "4ii", xdg_shell_types + 0 },
-	{ "wm_capabilities", "5a", xdg_shell_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface xdg_toplevel_interface = {
-	"xdg_toplevel", 5,
-	14, xdg_toplevel_requests,
-	4, xdg_toplevel_events,
-};
-
-static const struct wl_message xdg_popup_requests[] = {
-	{ "destroy", "", xdg_shell_types + 0 },
-	{ "grab", "ou", xdg_shell_types + 22 },
-	{ "reposition", "3ou", xdg_shell_types + 24 },
-};
-
-static const struct wl_message xdg_popup_events[] = {
-	{ "configure", "iiii", xdg_shell_types + 0 },
-	{ "popup_done", "", xdg_shell_types + 0 },
-	{ "repositioned", "3u", xdg_shell_types + 0 },
-};
-
-WL_PRIVATE const struct wl_interface xdg_popup_interface = {
-	"xdg_popup", 5,
-	3, xdg_popup_requests,
-	3, xdg_popup_events,
-};
-
-- 
2.39.1


From 35691274a935e24c5bccd6931235aa759f32232e Mon Sep 17 00:00:00 2001
From: MadcowOG <N/A>
Date: Wed, 22 Feb 2023 22:45:42 -0800
Subject: [PATCH 11/11] Readme change

---
 README.md | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/README.md b/README.md
index b5e2507..d9b576b 100644
--- a/README.md
+++ b/README.md
@@ -3,20 +3,19 @@ dwm-like bar for dwl
 
 I believe dwl-bar provides a more dwm-like experience out of the box than other bars like somebar.
 
-Still in development. But should compile.
-
 ## Dependencies
 I'm not sure what the package names will be for your distrobution, so just make sure these are generally what you have.
+ + make
  + pango
  + cairo
  + wayland
  + wayland-protocols
 
 ## Compile
-Compile with this command `gcc ./src/*.c -o ./bar $(pkg-config --cflags --libs wayland-client wayland-cursor pangocairo)`.
+Compile with `make`, install with `make install`, uninstall `make uninstall`.
 
 ## Configuration
-Like most suckless-like software, configuration is done through `src/config.def.h` modify it to your heart's content.
+Like most suckless-like software, configuration is done through `src/config.def.h` modify it to your heart's content. dwl-bar is compatible with [someblocks](https://sr.ht/~raphi/someblocks/) for status.
 
 ## Thanks
 Thanks to raphi for somebar this project is largely just somebar but in C and a few tweaks to make it similar to dwm. The ipc protocol is also just the ipc patch in somebar's `contrib/`.
-- 
2.39.1

